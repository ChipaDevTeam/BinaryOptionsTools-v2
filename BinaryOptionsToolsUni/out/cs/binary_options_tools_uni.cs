// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.0+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
namespace uniffi.binary_options_tools_uni;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            var buffer = _UniFFILib.ffi_binary_options_tools_uni_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.ffi_binary_options_tools_uni_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException: System.Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

internal class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

internal class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

internal class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

internal class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

internal class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

internal class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

internal class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: System.Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}

static class FFIObjectUtil {
    public static void DisposeAll(params Object?[] list) {
        foreach (var obj in list) {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(dynamic? obj) {
        if (obj == null) {
            return;
        }

        if (obj is IDisposable disposable) {
            disposable.Dispose();
            return;
        }

        var type = obj.GetType();
        if (type != null) {
            if (type.IsGenericType) {
                if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))) {
                    foreach (var value in obj) {
                        Dispose(value);
                    }
                } else if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>))) {
                    foreach (var value in obj.Values) {
                        Dispose(value);
                    }
                }
            }
        }
    }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: System.Exception {
    public StreamUnderflowException() {
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value) {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value) {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value) {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value) {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value) {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value) {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value) {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value) {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value) {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value) {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length) {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort() {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt() {
        CheckRemaining(4);
        return (uint)(stream.ReadByte() << 24
            | stream.ReadByte() << 16
            | stream.ReadByte() << 8
            | stream.ReadByte());
    }

    public ulong ReadULong() {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte() {
        return (sbyte)ReadByte();
    }

    public short ReadShort() {
        return (short)ReadUShort();
    }

    public int ReadInt() {
        return (int)ReadUInt();
    }

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() {
        return (long)ReadULong();
    }

    public double ReadDouble() {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib {
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(
        ulong @data,sbyte @pollResult
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(
        ulong @handle
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(
        ulong @handle
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructPointer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructVoid @result
    );
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        }

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_clone_pocketoption(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_binary_options_tools_uni_fn_free_pocketoption(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new(RustBuffer @ssid
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new_with_url(RustBuffer @ssid,RustBuffer @url
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_assets(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_balance(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_buy(IntPtr @ptr,RustBuffer @asset,uint @time,double @amount
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_clear_closed_deals(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles(IntPtr @ptr,RustBuffer @asset,long @period,long @offset
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles_advanced(IntPtr @ptr,RustBuffer @asset,long @period,long @time,long @offset
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_get_closed_deals(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_get_opened_deals(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_history(IntPtr @ptr,RustBuffer @asset,uint @period
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte uniffi_binary_options_tools_uni_fn_method_pocketoption_is_demo(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_reconnect(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_result(IntPtr @ptr,RustBuffer @id
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_result_with_timeout(IntPtr @ptr,RustBuffer @id,ulong @timeoutSecs
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_sell(IntPtr @ptr,RustBuffer @asset,uint @time,double @amount
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_server_time(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_shutdown(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_subscribe(IntPtr @ptr,RustBuffer @asset,ulong @durationSecs
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_trade(IntPtr @ptr,RustBuffer @asset,RustBuffer @action,uint @time,double @amount
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_pocketoption_unsubscribe(IntPtr @ptr,RustBuffer @asset
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_clone_subscriptionstream(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_binary_options_tools_uni_fn_free_subscriptionstream(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_binary_options_tools_uni_fn_method_subscriptionstream_next(IntPtr @ptr
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_binary_options_tools_uni_rustbuffer_alloc(ulong @size,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_binary_options_tools_uni_rustbuffer_from_bytes(ForeignBytes @bytes,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rustbuffer_free(RustBuffer @buf,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_binary_options_tools_uni_rustbuffer_reserve(RustBuffer @buf,ulong @additional,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_u8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_binary_options_tools_uni_rust_future_complete_u8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_i8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_binary_options_tools_uni_rust_future_complete_i8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_u16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_binary_options_tools_uni_rust_future_complete_u16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_i16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_binary_options_tools_uni_rust_future_complete_i16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_u32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_binary_options_tools_uni_rust_future_complete_u32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_i32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_binary_options_tools_uni_rust_future_complete_i32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_u64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_binary_options_tools_uni_rust_future_complete_u64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_i64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_binary_options_tools_uni_rust_future_complete_i64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_f32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_binary_options_tools_uni_rust_future_complete_f32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_f64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_binary_options_tools_uni_rust_future_complete_f64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_pointer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_binary_options_tools_uni_rust_future_complete_pointer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_poll_void(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_free_void(IntPtr @handle
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_binary_options_tools_uni_rust_future_complete_void(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_assets(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_balance(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_buy(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_clear_closed_deals(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles_advanced(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_closed_deals(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_opened_deals(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_history(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_is_demo(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_reconnect(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_result(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_result_with_timeout(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_sell(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_server_time(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_shutdown(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_subscribe(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_trade(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_pocketoption_unsubscribe(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_method_subscriptionstream_next(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new_with_url(
    );

    [DllImport("binary_options_tools_uni", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_binary_options_tools_uni_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_binary_options_tools_uni_uniffi_contract_version();
        if (26 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"uniffi.binary_options_tools_uni: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_assets();
            if (checksum != 48493) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_assets` checksum `48493`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_balance();
            if (checksum != 26020) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_balance` checksum `26020`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_buy();
            if (checksum != 63032) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_buy` checksum `63032`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_clear_closed_deals();
            if (checksum != 9178) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_clear_closed_deals` checksum `9178`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles();
            if (checksum != 23490) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles` checksum `23490`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles_advanced();
            if (checksum != 27509) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles_advanced` checksum `27509`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_closed_deals();
            if (checksum != 47785) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_closed_deals` checksum `47785`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_opened_deals();
            if (checksum != 27985) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_opened_deals` checksum `27985`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_history();
            if (checksum != 27093) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_history` checksum `27093`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_is_demo();
            if (checksum != 19411) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_is_demo` checksum `19411`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_reconnect();
            if (checksum != 9220) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_reconnect` checksum `9220`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result();
            if (checksum != 594) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_result` checksum `594`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_result_with_timeout();
            if (checksum != 56468) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_result_with_timeout` checksum `56468`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_sell();
            if (checksum != 61157) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_sell` checksum `61157`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_server_time();
            if (checksum != 10589) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_server_time` checksum `10589`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_shutdown();
            if (checksum != 51452) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_shutdown` checksum `51452`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_subscribe();
            if (checksum != 23382) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_subscribe` checksum `23382`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_trade();
            if (checksum != 14619) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_trade` checksum `14619`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_pocketoption_unsubscribe();
            if (checksum != 29837) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_pocketoption_unsubscribe` checksum `29837`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_method_subscriptionstream_next();
            if (checksum != 13448) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_method_subscriptionstream_next` checksum `13448`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new();
            if (checksum != 31315) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new` checksum `31315`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new_with_url();
            if (checksum != 40992) {
                throw new UniffiContractChecksumException($"uniffi.binary_options_tools_uni: uniffi bindings expected function `uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new_with_url` checksum `40992`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt32: FfiConverter<uint, uint> {
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value) {
        return value;
    }

    public override uint Read(BigEndianStream stream) {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value) {
        return value;
    }

    public override int AllocationSize(uint value) {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream) {
        stream.WriteUInt(value);
    }
}



class FfiConverterInt32: FfiConverter<int, int> {
    public static FfiConverterInt32 INSTANCE = new FfiConverterInt32();

    public override int Lift(int value) {
        return value;
    }

    public override int Read(BigEndianStream stream) {
        return stream.ReadInt();
    }

    public override int Lower(int value) {
        return value;
    }

    public override int AllocationSize(int value) {
        return 4;
    }

    public override void Write(int value, BigEndianStream stream) {
        stream.WriteInt(value);
    }
}



class FfiConverterUInt64: FfiConverter<ulong, ulong> {
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value) {
        return value;
    }

    public override ulong Read(BigEndianStream stream) {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value) {
        return value;
    }

    public override int AllocationSize(ulong value) {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream) {
        stream.WriteULong(value);
    }
}



class FfiConverterInt64: FfiConverter<long, long> {
    public static FfiConverterInt64 INSTANCE = new FfiConverterInt64();

    public override long Lift(long value) {
        return value;
    }

    public override long Read(BigEndianStream stream) {
        return stream.ReadLong();
    }

    public override long Lower(long value) {
        return value;
    }

    public override int AllocationSize(long value) {
        return 8;
    }

    public override void Write(long value, BigEndianStream stream) {
        stream.WriteLong(value);
    }
}



class FfiConverterDouble: FfiConverter<double, double> {
    public static FfiConverterDouble INSTANCE = new FfiConverterDouble();

    public override double Lift(double value) {
        return value;
    }

    public override double Read(BigEndianStream stream) {
        return stream.ReadDouble();
    }

    public override double Lower(double value) {
        return value;
    }

    public override int AllocationSize(double value) {
        return 8;
    }

    public override void Write(double value, BigEndianStream stream) {
        stream.WriteDouble(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}



/// <summary>
/// The main client for interacting with the PocketOption platform.
///
/// This object provides all the functionality needed to connect to PocketOption,
/// place trades, get account information, and subscribe to market data.
///
/// It is the primary entry point for using this library.
///
/// # Rationale
///
/// This struct wraps the underlying `binary_options_tools::pocketoption::PocketOption` client,
/// exposing its functionality in a way that is compatible with UniFFI for creating
/// multi-language bindings.
/// </summary>
internal interface IPocketOption {
    /// <summary>
    /// Gets the list of available assets for trading.
    ///
    /// # Returns
    ///
    /// A list of `Asset` objects, or `None` if the assets have not been loaded yet.
    /// </summary>
    Task<List<Asset>?> Assets();
    /// <summary>
    /// Gets the current balance of the account.
    ///
    /// This method retrieves the current trading balance from the client's state.
    ///
    /// # Returns
    ///
    /// The current balance as a floating-point number.
    /// </summary>
    Task<double> Balance();
    /// <summary>
    /// Places a "Call" (buy) trade.
    ///
    /// This is a convenience method that calls `trade` with `Action.Call`.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<Deal> Buy(string @asset, uint @time, double @amount);
    /// <summary>
    /// Clears the list of closed deals from the client's state.
    /// </summary>
    Task ClearClosedDeals();
    /// <summary>
    /// Gets historical candle data for a specific asset.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<List<Candle>> GetCandles(string @asset, long @period, long @offset);
    /// <summary>
    /// Gets historical candle data for a specific asset with advanced parameters.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<List<Candle>> GetCandlesAdvanced(string @asset, long @period, long @time, long @offset);
    /// <summary>
    /// Gets the list of currently closed deals.
    /// </summary>
    Task<List<Deal>> GetClosedDeals();
    /// <summary>
    /// Gets the list of currently opened deals.
    /// </summary>
    Task<List<Deal>> GetOpenedDeals();
    /// <summary>
    /// Gets historical candle data for a specific asset and period.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<List<Candle>> History(string @asset, uint @period);
    /// <summary>
    /// Checks if the current session is a demo account.
    ///
    /// # Returns
    ///
    /// `true` if the account is a demo account, `false` otherwise.
    /// </summary>
    bool IsDemo();
    /// <summary>
    /// Disconnects and reconnects the client.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task Reconnect();
    /// <summary>
    /// Checks the result of a trade by its ID.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the trade to check (as a string).
    ///
    /// # Returns
    ///
    /// A `Deal` object representing the completed trade.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<Deal> Result(string @id);
    /// <summary>
    /// Checks the result of a trade by its ID with a timeout.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the trade to check (as a string).
    /// * `timeout_secs` - The maximum time to wait for the result in seconds.
    ///
    /// # Returns
    ///
    /// A `Deal` object representing the completed trade.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<Deal> ResultWithTimeout(string @id, ulong @timeoutSecs);
    /// <summary>
    /// Places a "Put" (sell) trade.
    ///
    /// This is a convenience method that calls `trade` with `Action.Put`.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<Deal> Sell(string @asset, uint @time, double @amount);
    /// <summary>
    /// Gets the current server time as a Unix timestamp.
    /// </summary>
    Task<long> ServerTime();
    /// <summary>
    /// Shuts down the client and stops all background tasks.
    ///
    /// This method should be called when you are finished with the client
    /// to ensure a graceful shutdown.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task Shutdown();
    /// <summary>
    /// Subscribes to real-time candle data for a specific asset.
    ///
    /// # Arguments
    ///
    /// * `asset` - The symbol of the asset to subscribe to.
    /// * `duration_secs` - The duration of each candle in seconds.
    ///
    /// # Returns
    ///
    /// A `SubscriptionStream` object that can be used to receive candle data.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<SubscriptionStream> Subscribe(string @asset, ulong @durationSecs);
    /// <summary>
    /// Places a trade.
    ///
    /// This is the core method for executing trades.
    ///
    /// # Arguments
    ///
    /// * `asset` - The symbol of the asset to trade (e.g., "EURUSD_otc").
    /// * `action` - The direction of the trade (`Action.Call` or `Action.Put`).
    /// * `time` - The duration of the trade in seconds.
    /// * `amount` - The amount to trade.
    ///
    /// # Returns
    ///
    /// A `Deal` object representing the completed trade.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<Deal> Trade(string @asset, Action @action, uint @time, double @amount);
    /// <summary>
    /// Unsubscribes from real-time candle data for a specific asset.
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task Unsubscribe(string @asset);
}
/// <summary>
/// The main client for interacting with the PocketOption platform.
///
/// This object provides all the functionality needed to connect to PocketOption,
/// place trades, get account information, and subscribe to market data.
///
/// It is the primary entry point for using this library.
///
/// # Rationale
///
/// This struct wraps the underlying `binary_options_tools::pocketoption::PocketOption` client,
/// exposing its functionality in a way that is compatible with UniFFI for creating
/// multi-language bindings.
/// </summary>
internal class PocketOption : IPocketOption, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public PocketOption(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~PocketOption() {
        Destroy();
    }
    /// <summary>
    /// Creates a new instance of the PocketOption client.
    ///
    /// This is the primary constructor for the client. It requires a session ID (ssid)
    /// to authenticate with the PocketOption servers.
    ///
    /// # Arguments
    ///
    /// * `ssid` - The session ID for your PocketOption account.
    ///
    /// # Examples
    ///
    /// ## Python
    /// ```python
    /// import asyncio
    /// from binaryoptionstoolsuni import PocketOption
    ///
    /// async def main():
    /// ssid = "YOUR_SESSION_ID"
    /// api = await PocketOption.new(ssid)
    /// balance = await api.balance()
    /// print(f"Balance: {balance}")
    ///
    /// asyncio.run(main())
    /// ```
    /// </summary>
    public static async Task<PocketOption> PocketOptionAsync (string @ssid) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        _UniFFILib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new(FfiConverterString.INSTANCE.Lower(@ssid)),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypePocketOption.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_binary_options_tools_uni_fn_free_pocketoption(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_clone_pocketoption(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Gets the list of available assets for trading.
    ///
    /// # Returns
    ///
    /// A list of `Asset` objects, or `None` if the assets have not been loaded yet.
    /// </summary>
    public async Task<List<Asset>?> Assets() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_assets(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterOptionalSequenceTypeAsset.INSTANCE.Lift(result),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Gets the current balance of the account.
    ///
    /// This method retrieves the current trading balance from the client's state.
    ///
    /// # Returns
    ///
    /// The current balance as a floating-point number.
    /// </summary>
    public async Task<double> Balance() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_balance(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_f64(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_f64(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_f64(future),
        // Lift
        (result) => FfiConverterDouble.INSTANCE.Lift(result),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Places a "Call" (buy) trade.
    ///
    /// This is a convenience method that calls `trade` with `Action.Call`.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<Deal> Buy(string @asset, uint @time, double @amount) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_buy(thisPtr, FfiConverterString.INSTANCE.Lower(@asset), FfiConverterUInt32.INSTANCE.Lower(@time), FfiConverterDouble.INSTANCE.Lower(@amount));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeDeal.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Clears the list of closed deals from the client's state.
    /// </summary>
    public async Task ClearClosedDeals() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_clear_closed_deals(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Gets historical candle data for a specific asset.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<List<Candle>> GetCandles(string @asset, long @period, long @offset) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles(thisPtr, FfiConverterString.INSTANCE.Lower(@asset), FfiConverterInt64.INSTANCE.Lower(@period), FfiConverterInt64.INSTANCE.Lower(@offset));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeCandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Gets historical candle data for a specific asset with advanced parameters.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<List<Candle>> GetCandlesAdvanced(string @asset, long @period, long @time, long @offset) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles_advanced(thisPtr, FfiConverterString.INSTANCE.Lower(@asset), FfiConverterInt64.INSTANCE.Lower(@period), FfiConverterInt64.INSTANCE.Lower(@time), FfiConverterInt64.INSTANCE.Lower(@offset));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeCandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Gets the list of currently closed deals.
    /// </summary>
    public async Task<List<Deal>> GetClosedDeals() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_closed_deals(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeDeal.INSTANCE.Lift(result),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Gets the list of currently opened deals.
    /// </summary>
    public async Task<List<Deal>> GetOpenedDeals() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_get_opened_deals(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeDeal.INSTANCE.Lift(result),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Gets historical candle data for a specific asset and period.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<List<Candle>> History(string @asset, uint @period) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_history(thisPtr, FfiConverterString.INSTANCE.Lower(@asset), FfiConverterUInt32.INSTANCE.Lower(@period));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeCandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Checks if the current session is a demo account.
    ///
    /// # Returns
    ///
    /// `true` if the account is a demo account, `false` otherwise.
    /// </summary>
    public bool IsDemo() {
        return CallWithPointer(thisPtr => FfiConverterBoolean.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_is_demo(thisPtr,  ref _status)
)));
    }
    
    
    /// <summary>
    /// Disconnects and reconnects the client.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task Reconnect() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_reconnect(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_void(future),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Checks the result of a trade by its ID.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the trade to check (as a string).
    ///
    /// # Returns
    ///
    /// A `Deal` object representing the completed trade.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<Deal> Result(string @id) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result(thisPtr, FfiConverterString.INSTANCE.Lower(@id));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeDeal.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Checks the result of a trade by its ID with a timeout.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the trade to check (as a string).
    /// * `timeout_secs` - The maximum time to wait for the result in seconds.
    ///
    /// # Returns
    ///
    /// A `Deal` object representing the completed trade.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<Deal> ResultWithTimeout(string @id, ulong @timeoutSecs) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_result_with_timeout(thisPtr, FfiConverterString.INSTANCE.Lower(@id), FfiConverterUInt64.INSTANCE.Lower(@timeoutSecs));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeDeal.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Places a "Put" (sell) trade.
    ///
    /// This is a convenience method that calls `trade` with `Action.Put`.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<Deal> Sell(string @asset, uint @time, double @amount) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_sell(thisPtr, FfiConverterString.INSTANCE.Lower(@asset), FfiConverterUInt32.INSTANCE.Lower(@time), FfiConverterDouble.INSTANCE.Lower(@amount));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeDeal.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Gets the current server time as a Unix timestamp.
    /// </summary>
    public async Task<long> ServerTime() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_server_time(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_i64(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_i64(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_i64(future),
        // Lift
        (result) => FfiConverterInt64.INSTANCE.Lift(result),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Shuts down the client and stops all background tasks.
    ///
    /// This method should be called when you are finished with the client
    /// to ensure a graceful shutdown.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task Shutdown() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_shutdown(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_void(future),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Subscribes to real-time candle data for a specific asset.
    ///
    /// # Arguments
    ///
    /// * `asset` - The symbol of the asset to subscribe to.
    /// * `duration_secs` - The duration of each candle in seconds.
    ///
    /// # Returns
    ///
    /// A `SubscriptionStream` object that can be used to receive candle data.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<SubscriptionStream> Subscribe(string @asset, ulong @durationSecs) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_subscribe(thisPtr, FfiConverterString.INSTANCE.Lower(@asset), FfiConverterUInt64.INSTANCE.Lower(@durationSecs));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeSubscriptionStream.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Places a trade.
    ///
    /// This is the core method for executing trades.
    ///
    /// # Arguments
    ///
    /// * `asset` - The symbol of the asset to trade (e.g., "EURUSD_otc").
    /// * `action` - The direction of the trade (`Action.Call` or `Action.Put`).
    /// * `time` - The duration of the trade in seconds.
    /// * `amount` - The amount to trade.
    ///
    /// # Returns
    ///
    /// A `Deal` object representing the completed trade.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<Deal> Trade(string @asset, Action @action, uint @time, double @amount) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_trade(thisPtr, FfiConverterString.INSTANCE.Lower(@asset), FfiConverterTypeAction.INSTANCE.Lower(@action), FfiConverterUInt32.INSTANCE.Lower(@time), FfiConverterDouble.INSTANCE.Lower(@amount));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeDeal.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    /// <summary>
    /// Unsubscribes from real-time candle data for a specific asset.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task Unsubscribe(string @asset) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_pocketoption_unsubscribe(thisPtr, FfiConverterString.INSTANCE.Lower(@asset));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_void(future),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    

    
    /// <summary>
    /// Creates a new instance of the PocketOption client with a custom WebSocket URL.
    ///
    /// This constructor is useful for connecting to different PocketOption servers,
    /// for example, in different regions.
    ///
    /// # Arguments
    ///
    /// * `ssid` - The session ID for your PocketOption account.
    /// * `url` - The custom WebSocket URL to connect to.
    /// </summary>
    /// <exception cref="UniException"></exception>
    public static async Task<PocketOption> NewWithUrl (string @ssid, string @url) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        _UniFFILib.uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new_with_url(FfiConverterString.INSTANCE.Lower(@ssid), FfiConverterString.INSTANCE.Lower(@url)),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypePocketOption.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    
    
}
class FfiConverterTypePocketOption: FfiConverter<PocketOption, IntPtr> {
    public static FfiConverterTypePocketOption INSTANCE = new FfiConverterTypePocketOption();


    public override IntPtr Lower(PocketOption value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override PocketOption Lift(IntPtr value) {
        return new PocketOption(value);
    }

    public override PocketOption Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(PocketOption value) {
        return 8;
    }

    public override void Write(PocketOption value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Represents a stream of subscription data.
///
/// This object is returned by the `subscribe` method on the `PocketOption` client.
/// It allows you to receive real-time data, such as candles, for a specific asset.
///
/// # Rationale
///
/// Since UniFFI does not support streams directly, this wrapper provides a way to
/// consume the stream by repeatedly calling the `next` method.
/// </summary>
internal interface ISubscriptionStream {
    /// <summary>
    /// Retrieves the next item from the stream.
    ///
    /// This method should be called in a loop to consume the data from the stream.
    /// It will return `None` when the stream is closed.
    ///
    /// # Returns
    ///
    /// An optional `Candle` object. It will be `None` if the stream has finished.
    ///
    /// # Examples
    ///
    /// ## Python
    /// ```python
    /// import asyncio
    ///
    /// async def main():
    /// # ... (get api object)
    /// stream = await api.subscribe("EURUSD_otc", 5)
    /// while True:
    /// candle = await stream.next()
    /// if candle is None:
    /// break
    /// print(f"New candle: {candle}")
    ///
    /// asyncio.run(main())
    /// ```
    ///
    /// ## Swift
    /// ```swift
    /// func subscribe() async {
    /// // ... (get api object)
    /// let stream = try! await api.subscribe(asset: "EURUSD_otc", durationSecs: 5)
    /// while let candle = try! await stream.next() {
    /// print("New candle: \(candle)")
    /// }
    /// }
    /// ```
    /// </summary>
    /// <exception cref="UniException"></exception>
    Task<Candle> Next();
}
/// <summary>
/// Represents a stream of subscription data.
///
/// This object is returned by the `subscribe` method on the `PocketOption` client.
/// It allows you to receive real-time data, such as candles, for a specific asset.
///
/// # Rationale
///
/// Since UniFFI does not support streams directly, this wrapper provides a way to
/// consume the stream by repeatedly calling the `next` method.
/// </summary>
internal class SubscriptionStream : ISubscriptionStream, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SubscriptionStream(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~SubscriptionStream() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_binary_options_tools_uni_fn_free_subscriptionstream(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_clone_subscriptionstream(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Retrieves the next item from the stream.
    ///
    /// This method should be called in a loop to consume the data from the stream.
    /// It will return `None` when the stream is closed.
    ///
    /// # Returns
    ///
    /// An optional `Candle` object. It will be `None` if the stream has finished.
    ///
    /// # Examples
    ///
    /// ## Python
    /// ```python
    /// import asyncio
    ///
    /// async def main():
    /// # ... (get api object)
    /// stream = await api.subscribe("EURUSD_otc", 5)
    /// while True:
    /// candle = await stream.next()
    /// if candle is None:
    /// break
    /// print(f"New candle: {candle}")
    ///
    /// asyncio.run(main())
    /// ```
    ///
    /// ## Swift
    /// ```swift
    /// func subscribe() async {
    /// // ... (get api object)
    /// let stream = try! await api.subscribe(asset: "EURUSD_otc", durationSecs: 5)
    /// while let candle = try! await stream.next() {
    /// print("New candle: \(candle)")
    /// }
    /// }
    /// ```
    /// </summary>
    /// <exception cref="UniException"></exception>
    public async Task<Candle> Next() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_binary_options_tools_uni_fn_method_subscriptionstream_next(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_binary_options_tools_uni_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_binary_options_tools_uni_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeCandle.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeUniError.INSTANCE
    );
    }
    

    
}
class FfiConverterTypeSubscriptionStream: FfiConverter<SubscriptionStream, IntPtr> {
    public static FfiConverterTypeSubscriptionStream INSTANCE = new FfiConverterTypeSubscriptionStream();


    public override IntPtr Lower(SubscriptionStream value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SubscriptionStream Lift(IntPtr value) {
        return new SubscriptionStream(value);
    }

    public override SubscriptionStream Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SubscriptionStream value) {
        return 8;
    }

    public override void Write(SubscriptionStream value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Represents a financial asset that can be traded.
///
/// This struct contains all the information about a specific asset, such as its name, symbol,
/// payout, and whether it's currently active.
///
/// # Examples
///
/// ## Python
/// ```python
/// from binaryoptionstoolsuni import Asset
///
/// # This is an example of how you might receive an Asset object
/// # from the API. You would not typically construct this yourself.
/// eurusd = Asset(id=1, name="EUR/USD", symbol="EURUSD_otc", is_otc=True, is_active=True, payout=85, allowed_candles=[], asset_type=AssetType.CURRENCY)
/// print(eurusd.name)
/// ```
/// </summary>
internal record Asset (
    int @id, 
    string @name, 
    string @symbol, 
    bool @isOtc, 
    bool @isActive, 
    int @payout, 
    List<CandleLength> @allowedCandles, 
    AssetType @assetType
) {
}

class FfiConverterTypeAsset: FfiConverterRustBuffer<Asset> {
    public static FfiConverterTypeAsset INSTANCE = new FfiConverterTypeAsset();

    public override Asset Read(BigEndianStream stream) {
        return new Asset(
            @id: FfiConverterInt32.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream),
            @symbol: FfiConverterString.INSTANCE.Read(stream),
            @isOtc: FfiConverterBoolean.INSTANCE.Read(stream),
            @isActive: FfiConverterBoolean.INSTANCE.Read(stream),
            @payout: FfiConverterInt32.INSTANCE.Read(stream),
            @allowedCandles: FfiConverterSequenceTypeCandleLength.INSTANCE.Read(stream),
            @assetType: FfiConverterTypeAssetType.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Asset value) {
        return 0
            + FfiConverterInt32.INSTANCE.AllocationSize(value.@id)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterString.INSTANCE.AllocationSize(value.@symbol)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isOtc)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isActive)
            + FfiConverterInt32.INSTANCE.AllocationSize(value.@payout)
            + FfiConverterSequenceTypeCandleLength.INSTANCE.AllocationSize(value.@allowedCandles)
            + FfiConverterTypeAssetType.INSTANCE.AllocationSize(value.@assetType);
    }

    public override void Write(Asset value, BigEndianStream stream) {
            FfiConverterInt32.INSTANCE.Write(value.@id, stream);
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterString.INSTANCE.Write(value.@symbol, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isOtc, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isActive, stream);
            FfiConverterInt32.INSTANCE.Write(value.@payout, stream);
            FfiConverterSequenceTypeCandleLength.INSTANCE.Write(value.@allowedCandles, stream);
            FfiConverterTypeAssetType.INSTANCE.Write(value.@assetType, stream);
    }
}



/// <summary>
/// Represents a single candle in a price chart.
///
/// A candle represents the price movement of an asset over a specific time period.
/// It contains the open, high, low, and close (OHLC) prices for that period.
///
/// # Examples
///
/// ## Python
/// ```python
/// from binaryoptionstoolsuni import Candle
///
/// # This is an example of how you might receive a Candle object
/// # from the API.
/// candle = ... # receive from api.get_candles() or stream.next()
/// print(f"Candle for {candle.symbol} at {candle.timestamp}: O={candle.open}, H={candle.high}, L={candle.low}, C={candle.close}")
/// ```
/// </summary>
internal record Candle (
    string @symbol, 
    long @timestamp, 
    double @open, 
    double @high, 
    double @low, 
    double @close, 
    double? @volume
) {
}

class FfiConverterTypeCandle: FfiConverterRustBuffer<Candle> {
    public static FfiConverterTypeCandle INSTANCE = new FfiConverterTypeCandle();

    public override Candle Read(BigEndianStream stream) {
        return new Candle(
            @symbol: FfiConverterString.INSTANCE.Read(stream),
            @timestamp: FfiConverterInt64.INSTANCE.Read(stream),
            @open: FfiConverterDouble.INSTANCE.Read(stream),
            @high: FfiConverterDouble.INSTANCE.Read(stream),
            @low: FfiConverterDouble.INSTANCE.Read(stream),
            @close: FfiConverterDouble.INSTANCE.Read(stream),
            @volume: FfiConverterOptionalDouble.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Candle value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@symbol)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@timestamp)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@open)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@high)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@low)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@close)
            + FfiConverterOptionalDouble.INSTANCE.AllocationSize(value.@volume);
    }

    public override void Write(Candle value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@symbol, stream);
            FfiConverterInt64.INSTANCE.Write(value.@timestamp, stream);
            FfiConverterDouble.INSTANCE.Write(value.@open, stream);
            FfiConverterDouble.INSTANCE.Write(value.@high, stream);
            FfiConverterDouble.INSTANCE.Write(value.@low, stream);
            FfiConverterDouble.INSTANCE.Write(value.@close, stream);
            FfiConverterOptionalDouble.INSTANCE.Write(value.@volume, stream);
    }
}



/// <summary>
/// Represents the duration of a candle.
///
/// This struct is a simple wrapper around a `u32` that represents the candle duration in seconds.
/// It is used in the `Asset` struct to specify the allowed candle lengths for an asset.
///
/// # Examples
///
/// ## Python
/// ```python
/// from binaryoptionstoolsuni import CandleLength
///
/// five_second_candle = CandleLength(time=5)
/// ```
/// </summary>
internal record CandleLength (
    uint @time
) {
}

class FfiConverterTypeCandleLength: FfiConverterRustBuffer<CandleLength> {
    public static FfiConverterTypeCandleLength INSTANCE = new FfiConverterTypeCandleLength();

    public override CandleLength Read(BigEndianStream stream) {
        return new CandleLength(
            @time: FfiConverterUInt32.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CandleLength value) {
        return 0
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@time);
    }

    public override void Write(CandleLength value, BigEndianStream stream) {
            FfiConverterUInt32.INSTANCE.Write(value.@time, stream);
    }
}



/// <summary>
/// Represents a completed trade.
///
/// This struct contains all the information about a trade that has been opened and subsequently closed.
/// It includes details such as the open and close prices, profit, and timestamps.
///
/// # Examples
///
/// ## Python
/// ```python
/// from binaryoptionstoolsuni import Deal
///
/// # This is an example of how you might receive a Deal object
/// # from the API after a trade is completed.
/// # You would not typically construct this yourself.
/// deal = ... # receive from api.result()
/// print(f"Trade {deal.id} on {deal.asset} resulted in a profit of {deal.profit}")
/// ```
/// </summary>
internal record Deal (
    string @id, 
    string @openTime, 
    string @closeTime, 
    long @openTimestamp, 
    long @closeTimestamp, 
    ulong @uid, 
    string? @requestId, 
    double @amount, 
    double @profit, 
    int @percentProfit, 
    int @percentLoss, 
    double @openPrice, 
    double @closePrice, 
    int @command, 
    string @asset, 
    uint @isDemo, 
    string @copyTicket, 
    int @openMs, 
    int? @closeMs, 
    int @optionType, 
    bool? @isRollover, 
    bool? @isCopySignal, 
    bool? @isAi, 
    string @currency, 
    double? @amountUsd, 
    double? @amountUsd2
) {
}

class FfiConverterTypeDeal: FfiConverterRustBuffer<Deal> {
    public static FfiConverterTypeDeal INSTANCE = new FfiConverterTypeDeal();

    public override Deal Read(BigEndianStream stream) {
        return new Deal(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @openTime: FfiConverterString.INSTANCE.Read(stream),
            @closeTime: FfiConverterString.INSTANCE.Read(stream),
            @openTimestamp: FfiConverterInt64.INSTANCE.Read(stream),
            @closeTimestamp: FfiConverterInt64.INSTANCE.Read(stream),
            @uid: FfiConverterUInt64.INSTANCE.Read(stream),
            @requestId: FfiConverterOptionalString.INSTANCE.Read(stream),
            @amount: FfiConverterDouble.INSTANCE.Read(stream),
            @profit: FfiConverterDouble.INSTANCE.Read(stream),
            @percentProfit: FfiConverterInt32.INSTANCE.Read(stream),
            @percentLoss: FfiConverterInt32.INSTANCE.Read(stream),
            @openPrice: FfiConverterDouble.INSTANCE.Read(stream),
            @closePrice: FfiConverterDouble.INSTANCE.Read(stream),
            @command: FfiConverterInt32.INSTANCE.Read(stream),
            @asset: FfiConverterString.INSTANCE.Read(stream),
            @isDemo: FfiConverterUInt32.INSTANCE.Read(stream),
            @copyTicket: FfiConverterString.INSTANCE.Read(stream),
            @openMs: FfiConverterInt32.INSTANCE.Read(stream),
            @closeMs: FfiConverterOptionalInt32.INSTANCE.Read(stream),
            @optionType: FfiConverterInt32.INSTANCE.Read(stream),
            @isRollover: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @isCopySignal: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @isAi: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @currency: FfiConverterString.INSTANCE.Read(stream),
            @amountUsd: FfiConverterOptionalDouble.INSTANCE.Read(stream),
            @amountUsd2: FfiConverterOptionalDouble.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Deal value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterString.INSTANCE.AllocationSize(value.@openTime)
            + FfiConverterString.INSTANCE.AllocationSize(value.@closeTime)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@openTimestamp)
            + FfiConverterInt64.INSTANCE.AllocationSize(value.@closeTimestamp)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@uid)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@requestId)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@amount)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@profit)
            + FfiConverterInt32.INSTANCE.AllocationSize(value.@percentProfit)
            + FfiConverterInt32.INSTANCE.AllocationSize(value.@percentLoss)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@openPrice)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@closePrice)
            + FfiConverterInt32.INSTANCE.AllocationSize(value.@command)
            + FfiConverterString.INSTANCE.AllocationSize(value.@asset)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@isDemo)
            + FfiConverterString.INSTANCE.AllocationSize(value.@copyTicket)
            + FfiConverterInt32.INSTANCE.AllocationSize(value.@openMs)
            + FfiConverterOptionalInt32.INSTANCE.AllocationSize(value.@closeMs)
            + FfiConverterInt32.INSTANCE.AllocationSize(value.@optionType)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isRollover)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isCopySignal)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@isAi)
            + FfiConverterString.INSTANCE.AllocationSize(value.@currency)
            + FfiConverterOptionalDouble.INSTANCE.AllocationSize(value.@amountUsd)
            + FfiConverterOptionalDouble.INSTANCE.AllocationSize(value.@amountUsd2);
    }

    public override void Write(Deal value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterString.INSTANCE.Write(value.@openTime, stream);
            FfiConverterString.INSTANCE.Write(value.@closeTime, stream);
            FfiConverterInt64.INSTANCE.Write(value.@openTimestamp, stream);
            FfiConverterInt64.INSTANCE.Write(value.@closeTimestamp, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@uid, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@requestId, stream);
            FfiConverterDouble.INSTANCE.Write(value.@amount, stream);
            FfiConverterDouble.INSTANCE.Write(value.@profit, stream);
            FfiConverterInt32.INSTANCE.Write(value.@percentProfit, stream);
            FfiConverterInt32.INSTANCE.Write(value.@percentLoss, stream);
            FfiConverterDouble.INSTANCE.Write(value.@openPrice, stream);
            FfiConverterDouble.INSTANCE.Write(value.@closePrice, stream);
            FfiConverterInt32.INSTANCE.Write(value.@command, stream);
            FfiConverterString.INSTANCE.Write(value.@asset, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@isDemo, stream);
            FfiConverterString.INSTANCE.Write(value.@copyTicket, stream);
            FfiConverterInt32.INSTANCE.Write(value.@openMs, stream);
            FfiConverterOptionalInt32.INSTANCE.Write(value.@closeMs, stream);
            FfiConverterInt32.INSTANCE.Write(value.@optionType, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@isRollover, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@isCopySignal, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@isAi, stream);
            FfiConverterString.INSTANCE.Write(value.@currency, stream);
            FfiConverterOptionalDouble.INSTANCE.Write(value.@amountUsd, stream);
            FfiConverterOptionalDouble.INSTANCE.Write(value.@amountUsd2, stream);
    }
}





/// <summary>
/// Represents the action to take in a trade.
///
/// This enum is used to specify whether a trade is a "Call" (buy) or a "Put" (sell).
/// It's a fundamental concept in binary options trading.
///
/// # Examples
///
/// ## Python
/// ```python
/// from binaryoptionstoolsuni import Action
///
/// buy_action = Action.CALL
/// sell_action = Action.PUT
/// ```
///
/// ## Swift
/// ```swift
/// import binaryoptionstoolsuni
///
/// let buyAction = Action.call
/// let sellAction = Action.put
/// ```
///
/// ## Kotlin
/// ```kotlin
/// import uniffi.binaryoptionstoolsuni.Action
///
/// val buyAction = Action.CALL
/// val sellAction = Action.PUT
/// ```
///
/// ## C#
/// ```csharp
/// using UniFFI.BinaryOptionsToolsUni;
///
/// var buyAction = Action.Call;
/// var sellAction = Action.Put;
/// ```
///
/// ## Go
/// ```go
/// import "github.com/your-repo/binaryoptionstoolsuni"
///
/// var buyAction = binaryoptionstoolsuni.ActionCall
/// var sellAction = binaryoptionstoolsuni.ActionPut
/// ```
/// </summary>
internal enum Action: int {
    
    Call,
    Put
}

class FfiConverterTypeAction: FfiConverterRustBuffer<Action> {
    public static FfiConverterTypeAction INSTANCE = new FfiConverterTypeAction();

    public override Action Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(Action), value)) {
            return (Action)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAction.Read()", value));
        }
    }

    public override int AllocationSize(Action value) {
        return 4;
    }

    public override void Write(Action value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







/// <summary>
/// Represents the type of an asset.
///
/// This enum is used to categorize assets into different types, such as stocks, currencies, etc.
/// This information can be useful for filtering and organizing assets.
///
/// # Examples
///
/// ## Python
/// ```python
/// from binaryoptionstoolsuni import AssetType
///
/// asset_type = AssetType.CURRENCY
/// ```
/// </summary>
internal enum AssetType: int {
    
    Stock,
    Currency,
    Commodity,
    Cryptocurrency,
    Index
}

class FfiConverterTypeAssetType: FfiConverterRustBuffer<AssetType> {
    public static FfiConverterTypeAssetType INSTANCE = new FfiConverterTypeAssetType();

    public override AssetType Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(AssetType), value)) {
            return (AssetType)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAssetType.Read()", value));
        }
    }

    public override int AllocationSize(AssetType value) {
        return 4;
    }

    public override void Write(AssetType value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







internal class UniException: UniffiException {
    UniException() : base() {}
    UniException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class BinaryOptions : UniException {
        // Members
        public string @v1;

        // Constructor
        public BinaryOptions(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class PocketOption : UniException {
        // Members
        public string @v1;

        // Constructor
        public PocketOption(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Uuid : UniException {
        // Members
        public string @v1;

        // Constructor
        public Uuid(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    

    
}

class FfiConverterTypeUniError : FfiConverterRustBuffer<UniException>, CallStatusErrorHandler<UniException> {
    public static FfiConverterTypeUniError INSTANCE = new FfiConverterTypeUniError();

    public override UniException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new UniException.BinaryOptions(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new UniException.PocketOption(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new UniException.Uuid(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeUniError.Read()", value));
        }
    }

    public override int AllocationSize(UniException value) {
        switch (value) {

            case UniException.BinaryOptions variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case UniException.PocketOption variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case UniException.Uuid variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeUniError.AllocationSize()", value));
        }
    }

    public override void Write(UniException value, BigEndianStream stream) {
        switch (value) {
            case UniException.BinaryOptions variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case UniException.PocketOption variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case UniException.Uuid variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeUniError.Write()", value));
        }
    }
}




class FfiConverterOptionalInt32: FfiConverterRustBuffer<int?> {
    public static FfiConverterOptionalInt32 INSTANCE = new FfiConverterOptionalInt32();

    public override int? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(int? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterInt32.INSTANCE.AllocationSize((int)value);
        }
    }

    public override void Write(int? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterInt32.INSTANCE.Write((int)value, stream);
        }
    }
}




class FfiConverterOptionalDouble: FfiConverterRustBuffer<double?> {
    public static FfiConverterOptionalDouble INSTANCE = new FfiConverterOptionalDouble();

    public override double? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterDouble.INSTANCE.Read(stream);
    }

    public override int AllocationSize(double? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterDouble.INSTANCE.AllocationSize((double)value);
        }
    }

    public override void Write(double? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterDouble.INSTANCE.Write((double)value, stream);
        }
    }
}




class FfiConverterOptionalBoolean: FfiConverterRustBuffer<bool?> {
    public static FfiConverterOptionalBoolean INSTANCE = new FfiConverterOptionalBoolean();

    public override bool? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterBoolean.INSTANCE.Read(stream);
    }

    public override int AllocationSize(bool? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterBoolean.INSTANCE.AllocationSize((bool)value);
        }
    }

    public override void Write(bool? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterBoolean.INSTANCE.Write((bool)value, stream);
        }
    }
}




class FfiConverterOptionalString: FfiConverterRustBuffer<string?> {
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}




class FfiConverterOptionalSequenceTypeAsset: FfiConverterRustBuffer<List<Asset>?> {
    public static FfiConverterOptionalSequenceTypeAsset INSTANCE = new FfiConverterOptionalSequenceTypeAsset();

    public override List<Asset>? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterSequenceTypeAsset.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<Asset>? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterSequenceTypeAsset.INSTANCE.AllocationSize((List<Asset>)value);
        }
    }

    public override void Write(List<Asset>? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterSequenceTypeAsset.INSTANCE.Write((List<Asset>)value, stream);
        }
    }
}




class FfiConverterSequenceTypeAsset: FfiConverterRustBuffer<List<Asset>> {
    public static FfiConverterSequenceTypeAsset INSTANCE = new FfiConverterSequenceTypeAsset();

    public override List<Asset> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Asset>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeAsset.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Asset> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeAsset.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Asset> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeAsset.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeCandle: FfiConverterRustBuffer<List<Candle>> {
    public static FfiConverterSequenceTypeCandle INSTANCE = new FfiConverterSequenceTypeCandle();

    public override List<Candle> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Candle>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeCandle.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Candle> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeCandle.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Candle> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeCandle.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeCandleLength: FfiConverterRustBuffer<List<CandleLength>> {
    public static FfiConverterSequenceTypeCandleLength INSTANCE = new FfiConverterSequenceTypeCandleLength();

    public override List<CandleLength> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<CandleLength>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeCandleLength.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<CandleLength> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeCandleLength.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<CandleLength> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeCandleLength.INSTANCE.Write(item, stream));
    }
}




class FfiConverterSequenceTypeDeal: FfiConverterRustBuffer<List<Deal>> {
    public static FfiConverterSequenceTypeDeal INSTANCE = new FfiConverterSequenceTypeDeal();

    public override List<Deal> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Deal>(length);
        for (int i = 0; i < length; i++) {
            result.Add(FfiConverterTypeDeal.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Deal> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var sizeForItems = value.Select(item => FfiConverterTypeDeal.INSTANCE.AllocationSize(item)).Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Deal> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterTypeDeal.INSTANCE.Write(item, stream));
    }
}



class ConcurrentHandleMap<T> where T: notnull {
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj) {
        lock (lock_) {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result) {
        lock (lock_) {
            #pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
            #pragma warning restore 8601
        }
    }

    public T Get(ulong handle) {
        if (TryGet(handle, out var result)) {
            return result;
        } else {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle) {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result) {
        lock (lock_) {
            // Possible null reference assignment
            #pragma warning disable 8601
            if (map.TryGetValue(handle, out result)) {
            #pragma warning restore 8601
                map.Remove(handle);
                return true;
            } else {
                return false;
            }
        }
    }
}

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
delegate void UniFfiFutureCallback(IntPtr continuationHandle, byte pollResult);

internal static class _UniFFIAsync {
    internal const byte UNIFFI_RUST_FUTURE_POLL_READY = 0;
    // internal const byte UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1;

    internal static ConcurrentHandleMap<TaskCompletionSource<byte>> _async_handle_map = new ConcurrentHandleMap<TaskCompletionSource<byte>>();
    public static ConcurrentHandleMap<CancellationTokenSource> _foreign_futures_map = new ConcurrentHandleMap<CancellationTokenSource>();

    // FFI type for Rust future continuations
    internal class UniffiRustFutureContinuationCallback
    {
        public static UniFfiFutureCallback callback = Callback;

        public static void Callback(IntPtr continuationHandle, byte pollResult)
        {
            if (_async_handle_map.Remove((ulong)continuationHandle.ToInt64(), out TaskCompletionSource<byte> task))
            {
                task.SetResult(pollResult);
            }
            else 
            {
                throw new InternalException($"Unable to find continuation handle: {continuationHandle}");
            }
        }
    }

    public class UniffiForeignFutureFreeCallback
    {
        public static _UniFFILib.UniffiForeignFutureFree callback = Callback;

        public static void Callback(ulong handle)
        {
            if (_foreign_futures_map.Remove(handle, out CancellationTokenSource task))
            {
                task.Cancel();
            }
            else
            {
                throw new InternalException($"Unable to find cancellation token: {handle}");
            }
        }
    }

    public delegate F CompleteFuncDelegate<F>(IntPtr ptr, ref UniffiRustCallStatus status);

    public delegate void CompleteActionDelegate(IntPtr ptr, ref UniffiRustCallStatus status);

    private static async Task PollFuture(IntPtr rustFuture, Action<IntPtr, IntPtr, IntPtr> pollFunc)
    {
        byte pollResult;
        do 
        {
            var tcs = new TaskCompletionSource<byte>(TaskCreationOptions.RunContinuationsAsynchronously);
            IntPtr callback = Marshal.GetFunctionPointerForDelegate(UniffiRustFutureContinuationCallback.callback);
            ulong mapEntry = _async_handle_map.Insert(tcs);
            pollFunc(rustFuture, callback, (IntPtr)mapEntry);
            pollResult = await tcs.Task;
        }
        while(pollResult != UNIFFI_RUST_FUTURE_POLL_READY);
    }

    public static async Task<T> UniffiRustCallAsync<T, F, E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteFuncDelegate<F> completeFunc,
        Action<IntPtr> freeFunc,
        Func<F, T> liftFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
        try {
            await PollFuture(rustFuture, pollFunc);
            var result = _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));
            return liftFunc(result);
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }

    public static async Task UniffiRustCallAsync<E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteActionDelegate completeFunc,
        Action<IntPtr> freeFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
         try {
            await PollFuture(rustFuture, pollFunc);
            _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));

        }
        finally
        {
            freeFunc(rustFuture);
        }
    }
}
#pragma warning restore 8625
internal static class BinaryOptionsToolsUniMethods {
}

