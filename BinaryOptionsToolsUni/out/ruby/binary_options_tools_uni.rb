# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'


module BinaryOptionsToolsUni
  def self.uniffi_in_range(i, type_name, min, max)
  raise TypeError, "no implicit conversion of #{i} into Integer" unless i.respond_to?(:to_int)
  i = i.to_int
  raise RangeError, "#{type_name} requires #{min} <= value < #{max}" unless (min <= i && i < max)
  i
end

def self.uniffi_utf8(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v = v.to_str.encode(Encoding::UTF_8)
  raise Encoding::InvalidByteSequenceError, "not a valid UTF-8 encoded string" unless v.valid_encoding?
  v
end

def self.uniffi_bytes(v)
  raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)
  v.to_str
end

  class RustBuffer < FFI::Struct
  layout :capacity, :uint64,
         :len,      :uint64,
         :data,     :pointer

  def self.alloc(size)
    return BinaryOptionsToolsUni.rust_call(:ffi_binary_options_tools_uni_rustbuffer_alloc, size)
  end

  def self.reserve(rbuf, additional)
    return BinaryOptionsToolsUni.rust_call(:ffi_binary_options_tools_uni_rustbuffer_reserve, rbuf, additional)
  end

  def free
    BinaryOptionsToolsUni.rust_call(:ffi_binary_options_tools_uni_rustbuffer_free, self)
  end

  def capacity
    self[:capacity]
  end

  def len
    self[:len]
  end

  def len=(value)
    self[:len] = value
  end

  def data
    self[:data]
  end

  def to_s
    "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
  end

  # The allocated buffer will be automatically freed if an error occurs, ensuring that
  # we don't accidentally leak it.
  def self.allocWithBuilder
    builder = RustBufferBuilder.new

    begin
      yield builder
    rescue => e
      builder.discard
      raise e
    end
  end

  # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
  # leak it even if an error occurs.
  def consumeWithStream
    stream = RustBufferStream.new self

    yield stream

    raise RuntimeError, 'junk data left in buffer after consuming' if stream.remaining != 0
  ensure
    free
  end# The primitive String type.

  def self.allocFromString(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write value.encode('utf-8')
      return builder.finalize
    end
  end

  def consumeIntoString
    consumeWithStream do |stream|
      return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
    end
  end

  # The Record type Asset.

  def self.check_lower_TypeAsset(v)
    
    
    
    
    
    
    RustBuffer.check_lower_SequenceTypeCandleLength(v.allowed_candles)
    RustBuffer.check_lower_TypeAssetType(v.asset_type)
  end

  def self.alloc_from_TypeAsset(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeAsset(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeAsset
    consumeWithStream do |stream|
      return stream.readTypeAsset
    end
  end

  # The Record type Candle.

  def self.check_lower_TypeCandle(v)
    
    
    
    
    
    
    RustBuffer.check_lower_Optionalf64(v.volume)
  end

  def self.alloc_from_TypeCandle(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeCandle(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeCandle
    consumeWithStream do |stream|
      return stream.readTypeCandle
    end
  end

  # The Record type CandleLength.

  def self.check_lower_TypeCandleLength(v)
    
  end

  def self.alloc_from_TypeCandleLength(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeCandleLength(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeCandleLength
    consumeWithStream do |stream|
      return stream.readTypeCandleLength
    end
  end

  # The Record type Deal.

  def self.check_lower_TypeDeal(v)
    
    
    
    
    
    
    RustBuffer.check_lower_Optionalstring(v.request_id)
    
    
    
    
    
    
    
    
    
    
    
    RustBuffer.check_lower_Optionali32(v.close_ms)
    
    RustBuffer.check_lower_Optionalbool(v.is_rollover)
    RustBuffer.check_lower_Optionalbool(v.is_copy_signal)
    RustBuffer.check_lower_Optionalbool(v.is_ai)
    
    RustBuffer.check_lower_Optionalf64(v.amount_usd)
    RustBuffer.check_lower_Optionalf64(v.amount_usd2)
  end

  def self.alloc_from_TypeDeal(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeDeal(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeDeal
    consumeWithStream do |stream|
      return stream.readTypeDeal
    end
  end

  # The Enum type Action.

  def self.check_lower_TypeAction(v)
  end

  def self.alloc_from_TypeAction(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeAction(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeAction
    consumeWithStream do |stream|
      return stream.readTypeAction
    end
  end
  

  # The Enum type AssetType.

  def self.check_lower_TypeAssetType(v)
  end

  def self.alloc_from_TypeAssetType(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeAssetType(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeAssetType
    consumeWithStream do |stream|
      return stream.readTypeAssetType
    end
  end
  

  

  # The Optional<T> type for i32.

  def self.check_lower_Optionali32(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionali32(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionali32(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionali32
    consumeWithStream do |stream|
      return stream.readOptionali32
    end
  end

  # The Optional<T> type for f64.

  def self.check_lower_Optionalf64(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalf64(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalf64(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalf64
    consumeWithStream do |stream|
      return stream.readOptionalf64
    end
  end

  # The Optional<T> type for bool.

  def self.check_lower_Optionalbool(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalbool(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalbool(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalbool
    consumeWithStream do |stream|
      return stream.readOptionalbool
    end
  end

  # The Optional<T> type for string.

  def self.check_lower_Optionalstring(v)
    if not v.nil?
      
    end
  end

  def self.alloc_from_Optionalstring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalstring(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalstring
    consumeWithStream do |stream|
      return stream.readOptionalstring
    end
  end

  # The Optional<T> type for SequenceTypeAsset.

  def self.check_lower_OptionalSequenceTypeAsset(v)
    if not v.nil?
      RustBuffer.check_lower_SequenceTypeAsset(v)
    end
  end

  def self.alloc_from_OptionalSequenceTypeAsset(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalSequenceTypeAsset(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalSequenceTypeAsset
    consumeWithStream do |stream|
      return stream.readOptionalSequenceTypeAsset
    end
  end

  # The Sequence<T> type for TypeAsset.

  def self.check_lower_SequenceTypeAsset(v)
    v.each do |item|
      RustBuffer.check_lower_TypeAsset(item)
    end
  end

  def self.alloc_from_SequenceTypeAsset(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeAsset(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeAsset
    consumeWithStream do |stream|
      return stream.readSequenceTypeAsset
    end
  end

  # The Sequence<T> type for TypeCandle.

  def self.check_lower_SequenceTypeCandle(v)
    v.each do |item|
      RustBuffer.check_lower_TypeCandle(item)
    end
  end

  def self.alloc_from_SequenceTypeCandle(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeCandle(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeCandle
    consumeWithStream do |stream|
      return stream.readSequenceTypeCandle
    end
  end

  # The Sequence<T> type for TypeCandleLength.

  def self.check_lower_SequenceTypeCandleLength(v)
    v.each do |item|
      RustBuffer.check_lower_TypeCandleLength(item)
    end
  end

  def self.alloc_from_SequenceTypeCandleLength(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeCandleLength(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeCandleLength
    consumeWithStream do |stream|
      return stream.readSequenceTypeCandleLength
    end
  end

  # The Sequence<T> type for TypeDeal.

  def self.check_lower_SequenceTypeDeal(v)
    v.each do |item|
      RustBuffer.check_lower_TypeDeal(item)
    end
  end

  def self.alloc_from_SequenceTypeDeal(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeDeal(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeDeal
    consumeWithStream do |stream|
      return stream.readSequenceTypeDeal
    end
  end

  
end

module UniFFILib
  class ForeignBytes < FFI::Struct
    layout :len,      :int32,
           :data,     :pointer

    def len
      self[:len]
    end

    def data
      self[:data]
    end

    def to_s
      "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
    end
  end
end

private_constant :UniFFILib
  
# Helper for structured reading of values from a RustBuffer.
class RustBufferStream

  def initialize(rbuf)
    @rbuf = rbuf
    @offset = 0
  end

  def remaining
    @rbuf.len - @offset
  end

  def read(size)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    data = @rbuf.data.get_bytes @offset, size

    @offset += size

    data
  end

  def readU32
    unpack_from 4, 'L>'
  end

  def readI32
    unpack_from 4, 'l>'
  end

  def readU64
    unpack_from 8, 'Q>'
  end

  def readI64
    unpack_from 8, 'q>'
  end

  def readF64
    unpack_from 8, 'G'
  end

  def readBool
    v = unpack_from 1, 'c'

    return false if v == 0
    return true if v == 1

    raise InternalError, 'Unexpected byte for Boolean type'
  end

  def readString
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative string length' if size.negative?

    read(size).force_encoding(Encoding::UTF_8)
  end

  # The Object type PocketOption.

  def readTypePocketOption
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return PocketOption.uniffi_allocate(pointer)
  end

  # The Object type SubscriptionStream.

  def readTypeSubscriptionStream
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return SubscriptionStream.uniffi_allocate(pointer)
  end

  # The Record type Asset.

  def readTypeAsset
    Asset.new(
      id: readI32,
      name: readString,
      symbol: readString,
      is_otc: readBool,
      is_active: readBool,
      payout: readI32,
      allowed_candles: readSequenceTypeCandleLength,
      asset_type: readTypeAssetType
    )
  end

  # The Record type Candle.

  def readTypeCandle
    Candle.new(
      symbol: readString,
      timestamp: readI64,
      open: readF64,
      high: readF64,
      low: readF64,
      close: readF64,
      volume: readOptionalf64
    )
  end

  # The Record type CandleLength.

  def readTypeCandleLength
    CandleLength.new(
      time: readU32
    )
  end

  # The Record type Deal.

  def readTypeDeal
    Deal.new(
      id: readString,
      open_time: readString,
      close_time: readString,
      open_timestamp: readI64,
      close_timestamp: readI64,
      uid: readU64,
      request_id: readOptionalstring,
      amount: readF64,
      profit: readF64,
      percent_profit: readI32,
      percent_loss: readI32,
      open_price: readF64,
      close_price: readF64,
      command: readI32,
      asset: readString,
      is_demo: readU32,
      copy_ticket: readString,
      open_ms: readI32,
      close_ms: readOptionali32,
      option_type: readI32,
      is_rollover: readOptionalbool,
      is_copy_signal: readOptionalbool,
      is_ai: readOptionalbool,
      currency: readString,
      amount_usd: readOptionalf64,
      amount_usd2: readOptionalf64
    )
  end

  
  
  # The Enum type Action.

  def readTypeAction
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return Action::CALL
    end
    if variant == 2
      return Action::PUT
    end

    raise InternalError, 'Unexpected variant tag for TypeAction'
  end

  

  
  
  # The Enum type AssetType.

  def readTypeAssetType
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return AssetType::STOCK
    end
    if variant == 2
      return AssetType::CURRENCY
    end
    if variant == 3
      return AssetType::COMMODITY
    end
    if variant == 4
      return AssetType::CRYPTOCURRENCY
    end
    if variant == 5
      return AssetType::INDEX
    end

    raise InternalError, 'Unexpected variant tag for TypeAssetType'
  end

  

  

  

  # The Error type UniError

  def readTypeUniError
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return UniError::BinaryOptions.new(
            readString()
        )
    end
    if variant == 2
        return UniError::PocketOption.new(
            readString()
        )
    end
    if variant == 3
        return UniError::Uuid.new(
            readString()
        )
    end

    raise InternalError, 'Unexpected variant tag for TypeUniError'
  end
  

  # The Optional<T> type for i32.

  def readOptionali32
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readI32
    else
      raise InternalError, 'Unexpected flag byte for Optionali32'
    end
  end

  # The Optional<T> type for f64.

  def readOptionalf64
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readF64
    else
      raise InternalError, 'Unexpected flag byte for Optionalf64'
    end
  end

  # The Optional<T> type for bool.

  def readOptionalbool
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readBool
    else
      raise InternalError, 'Unexpected flag byte for Optionalbool'
    end
  end

  # The Optional<T> type for string.

  def readOptionalstring
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readString
    else
      raise InternalError, 'Unexpected flag byte for Optionalstring'
    end
  end

  # The Optional<T> type for SequenceTypeAsset.

  def readOptionalSequenceTypeAsset
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readSequenceTypeAsset
    else
      raise InternalError, 'Unexpected flag byte for OptionalSequenceTypeAsset'
    end
  end

  # The Sequence<T> type for TypeAsset.

  def readSequenceTypeAsset
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeAsset
    end

    items
  end

  # The Sequence<T> type for TypeCandle.

  def readSequenceTypeCandle
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeCandle
    end

    items
  end

  # The Sequence<T> type for TypeCandleLength.

  def readSequenceTypeCandleLength
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeCandleLength
    end

    items
  end

  # The Sequence<T> type for TypeDeal.

  def readSequenceTypeDeal
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeDeal
    end

    items
  end

  

  def unpack_from(size, format)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    value = @rbuf.data.get_bytes(@offset, size).unpack format

    @offset += size

    # TODO: verify this
    raise 'more than one element!!!' if value.size > 1

    value[0]
  end
end

private_constant :RustBufferStream
  
# Helper for structured writing of values into a RustBuffer.
class RustBufferBuilder
  def initialize
    @rust_buf = RustBuffer.alloc 16
    @rust_buf.len = 0
  end

  def finalize
    rbuf = @rust_buf

    @rust_buf = nil

    rbuf
  end

  def discard
    return if @rust_buf.nil?

    rbuf = finalize
    rbuf.free
  end

  def write(value)
    reserve(value.bytes.size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
    end
  end

  def write_U32(v)
    v = BinaryOptionsToolsUni::uniffi_in_range(v, "u32", 0, 2**32)
    pack_into(4, 'L>', v)
  end

  def write_I32(v)
    v = BinaryOptionsToolsUni::uniffi_in_range(v, "i32", -2**31, 2**31)
    pack_into(4, 'l>', v)
  end

  def write_U64(v)
    v = BinaryOptionsToolsUni::uniffi_in_range(v, "u64", 0, 2**64)
    pack_into(8, 'Q>', v)
  end

  def write_I64(v)
    v = BinaryOptionsToolsUni::uniffi_in_range(v, "i64", -2**63, 2**63)
    pack_into(8, 'q>', v)
  end

  def write_F64(v)
    pack_into(8, 'G', v)
  end

  def write_Bool(v)
    pack_into(1, 'c', v ? 1 : 0)
  end

  def write_String(v)
    v = BinaryOptionsToolsUni::uniffi_utf8(v)
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  # The Object type PocketOption.

  def write_TypePocketOption(obj)
    pointer = PocketOption.uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type SubscriptionStream.

  def write_TypeSubscriptionStream(obj)
    pointer = SubscriptionStream.uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Record type Asset.

  def write_TypeAsset(v)
    self.write_I32(v.id)
    self.write_String(v.name)
    self.write_String(v.symbol)
    self.write_Bool(v.is_otc)
    self.write_Bool(v.is_active)
    self.write_I32(v.payout)
    self.write_SequenceTypeCandleLength(v.allowed_candles)
    self.write_TypeAssetType(v.asset_type)
  end

  # The Record type Candle.

  def write_TypeCandle(v)
    self.write_String(v.symbol)
    self.write_I64(v.timestamp)
    self.write_F64(v.open)
    self.write_F64(v.high)
    self.write_F64(v.low)
    self.write_F64(v.close)
    self.write_Optionalf64(v.volume)
  end

  # The Record type CandleLength.

  def write_TypeCandleLength(v)
    self.write_U32(v.time)
  end

  # The Record type Deal.

  def write_TypeDeal(v)
    self.write_String(v.id)
    self.write_String(v.open_time)
    self.write_String(v.close_time)
    self.write_I64(v.open_timestamp)
    self.write_I64(v.close_timestamp)
    self.write_U64(v.uid)
    self.write_Optionalstring(v.request_id)
    self.write_F64(v.amount)
    self.write_F64(v.profit)
    self.write_I32(v.percent_profit)
    self.write_I32(v.percent_loss)
    self.write_F64(v.open_price)
    self.write_F64(v.close_price)
    self.write_I32(v.command)
    self.write_String(v.asset)
    self.write_U32(v.is_demo)
    self.write_String(v.copy_ticket)
    self.write_I32(v.open_ms)
    self.write_Optionali32(v.close_ms)
    self.write_I32(v.option_type)
    self.write_Optionalbool(v.is_rollover)
    self.write_Optionalbool(v.is_copy_signal)
    self.write_Optionalbool(v.is_ai)
    self.write_String(v.currency)
    self.write_Optionalf64(v.amount_usd)
    self.write_Optionalf64(v.amount_usd2)
  end

  # The Enum type Action.

  def write_TypeAction(v)
    pack_into(4, 'l>', v)
 end
   

  # The Enum type AssetType.

  def write_TypeAssetType(v)
    pack_into(4, 'l>', v)
 end
   

  

  # The Optional<T> type for i32.

  def write_Optionali32(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_I32(v)
    end
  end

  # The Optional<T> type for f64.

  def write_Optionalf64(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_F64(v)
    end
  end

  # The Optional<T> type for bool.

  def write_Optionalbool(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_Bool(v)
    end
  end

  # The Optional<T> type for string.

  def write_Optionalstring(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_String(v)
    end
  end

  # The Optional<T> type for SequenceTypeAsset.

  def write_OptionalSequenceTypeAsset(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_SequenceTypeAsset(v)
    end
  end

  # The Sequence<T> type for TypeAsset.

  def write_SequenceTypeAsset(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeAsset(item)
    end
  end

  # The Sequence<T> type for TypeCandle.

  def write_SequenceTypeCandle(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeCandle(item)
    end
  end

  # The Sequence<T> type for TypeCandleLength.

  def write_SequenceTypeCandleLength(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeCandleLength(item)
    end
  end

  # The Sequence<T> type for TypeDeal.

  def write_SequenceTypeDeal(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeDeal(item)
    end
  end

  

  private

  def reserve(num_bytes)
    if @rust_buf.len + num_bytes > @rust_buf.capacity
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes)
    end

    yield

    @rust_buf.len += num_bytes
  end

  def pack_into(size, format, value)
    reserve(size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
    end
  end
end

private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
  layout :code,    :int8,
         :error_buf, RustBuffer

  def code
    self[:code]
  end

  def error_buf
    self[:error_buf]
  end

  def to_s
    "RustCallStatus(code=#{self[:code]})"
  end
end

# These match the values from the uniffi::rustcalls module
CALL_SUCCESS = 0
CALL_ERROR = 1
CALL_PANIC = 2




module UniError
  class BinaryOptions < StandardError
    def initialize()
        @ = 
        super()
      end

    attr_reader :
    

    def to_s
     "#{self.class.name}(=#{@.inspect})"
    end
  end
  class PocketOption < StandardError
    def initialize()
        @ = 
        super()
      end

    attr_reader :
    

    def to_s
     "#{self.class.name}(=#{@.inspect})"
    end
  end
  class Uuid < StandardError
    def initialize()
        @ = 
        super()
      end

    attr_reader :
    

    def to_s
     "#{self.class.name}(=#{@.inspect})"
    end
  end

end


# Map error modules to the RustBuffer method name that reads them
ERROR_MODULE_TO_READER_METHOD = {



  UniError => :readTypeUniError,

}

private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                 :RustCallStatus

def self.consume_buffer_into_error(error_module, rust_buffer)
  rust_buffer.consumeWithStream do |stream|
    reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
    return stream.send(reader_method)
  end
end

class InternalError < StandardError
end

def self.rust_call(fn_name, *args)
  # Call a rust function
  rust_call_with_error(nil, fn_name, *args)
end

def self.rust_call_with_error(error_module, fn_name, *args)
  # Call a rust function and handle errors
  #
  # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.


  # Note: RustCallStatus.new zeroes out the struct, which is exactly what we
  # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
  # data=NULL))
  status = RustCallStatus.new
  args << status

  result = UniFFILib.public_send(fn_name, *args)

  case status.code
  when CALL_SUCCESS
    result
  when CALL_ERROR
    if error_module.nil?
      status.error_buf.free
      raise InternalError, "CALL_ERROR with no error_module set"
    else
      raise consume_buffer_into_error(error_module, status.error_buf)
    end
  when CALL_PANIC
    # When the rust code sees a panic, it tries to construct a RustBuffer
    # with the message.  But if that code panics, then it just sends back
    # an empty buffer.
    if status.error_buf.len > 0
      raise InternalError, status.error_buf.consumeIntoString()
    else
      raise InternalError, "Rust panic"
    end
  else
    raise InternalError, "Unknown call status: #{status.code}"
  end
end

private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
module UniFFILib
  extend FFI::Library

  
  ffi_lib 'binary_options_tools_uni'
  

  attach_function :uniffi_binary_options_tools_uni_fn_clone_pocketoption,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_binary_options_tools_uni_fn_free_pocketoption,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_binary_options_tools_uni_fn_constructor_pocketoption_init,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new_with_url,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_assets,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_balance,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_buy,
    [:pointer, RustBuffer.by_value, :uint32, :double, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_clear_closed_deals,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles,
    [:pointer, RustBuffer.by_value, :int64, :int64, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles_advanced,
    [:pointer, RustBuffer.by_value, :int64, :int64, :int64, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_get_closed_deals,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_get_opened_deals,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_history,
    [:pointer, RustBuffer.by_value, :uint32, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_is_demo,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_reconnect,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_result,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_result_with_timeout,
    [:pointer, RustBuffer.by_value, :uint64, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_sell,
    [:pointer, RustBuffer.by_value, :uint32, :double, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_server_time,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_shutdown,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_subscribe,
    [:pointer, RustBuffer.by_value, :uint64, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_trade,
    [:pointer, RustBuffer.by_value, RustBuffer.by_value, :uint32, :double, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_method_pocketoption_unsubscribe,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :uint64
  attach_function :uniffi_binary_options_tools_uni_fn_clone_subscriptionstream,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :uniffi_binary_options_tools_uni_fn_free_subscriptionstream,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :uniffi_binary_options_tools_uni_fn_method_subscriptionstream_next,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :ffi_binary_options_tools_uni_rustbuffer_alloc,
    [:uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_binary_options_tools_uni_rustbuffer_from_bytes,
    [ForeignBytes, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_binary_options_tools_uni_rustbuffer_free,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_binary_options_tools_uni_rustbuffer_reserve,
    [RustBuffer.by_value, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_assets,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_balance,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_buy,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_clear_closed_deals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_candles_advanced,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_closed_deals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_get_opened_deals,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_history,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_is_demo,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_reconnect,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_result,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_result_with_timeout,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_sell,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_server_time,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_shutdown,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_subscribe,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_trade,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_pocketoption_unsubscribe,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_method_subscriptionstream_next,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_init,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :uniffi_binary_options_tools_uni_checksum_constructor_pocketoption_new_with_url,
    [RustCallStatus.by_ref],
    :uint16
  attach_function :ffi_binary_options_tools_uni_uniffi_contract_version,
    [RustCallStatus.by_ref],
    :uint32
  
end

  # Public interface members begin here.

  
  
  

class Action
  CALL = 1
  PUT = 2
  
end


  
  
  

class AssetType
  STOCK = 1
  CURRENCY = 2
  COMMODITY = 3
  CRYPTOCURRENCY = 4
  INDEX = 5
  
end


  
  
  # Record type Asset
class Asset
  attr_reader :id, :name, :symbol, :is_otc, :is_active, :payout, :allowed_candles, :asset_type

  def initialize(id:, name:, symbol:, is_otc:, is_active:, payout:, allowed_candles:, asset_type:)
    @id = id
    @name = name
    @symbol = symbol
    @is_otc = is_otc
    @is_active = is_active
    @payout = payout
    @allowed_candles = allowed_candles
    @asset_type = asset_type
  end

  def ==(other)
    if @id != other.id
      return false
    end
    if @name != other.name
      return false
    end
    if @symbol != other.symbol
      return false
    end
    if @is_otc != other.is_otc
      return false
    end
    if @is_active != other.is_active
      return false
    end
    if @payout != other.payout
      return false
    end
    if @allowed_candles != other.allowed_candles
      return false
    end
    if @asset_type != other.asset_type
      return false
    end

    true
  end
end
  
  # Record type Candle
class Candle
  attr_reader :symbol, :timestamp, :open, :high, :low, :close, :volume

  def initialize(symbol:, timestamp:, open:, high:, low:, close:, volume:)
    @symbol = symbol
    @timestamp = timestamp
    @open = open
    @high = high
    @low = low
    @close = close
    @volume = volume
  end

  def ==(other)
    if @symbol != other.symbol
      return false
    end
    if @timestamp != other.timestamp
      return false
    end
    if @open != other.open
      return false
    end
    if @high != other.high
      return false
    end
    if @low != other.low
      return false
    end
    if @close != other.close
      return false
    end
    if @volume != other.volume
      return false
    end

    true
  end
end
  
  # Record type CandleLength
class CandleLength
  attr_reader :time

  def initialize(time:)
    @time = time
  end

  def ==(other)
    if @time != other.time
      return false
    end

    true
  end
end
  
  # Record type Deal
class Deal
  attr_reader :id, :open_time, :close_time, :open_timestamp, :close_timestamp, :uid, :request_id, :amount, :profit, :percent_profit, :percent_loss, :open_price, :close_price, :command, :asset, :is_demo, :copy_ticket, :open_ms, :close_ms, :option_type, :is_rollover, :is_copy_signal, :is_ai, :currency, :amount_usd, :amount_usd2

  def initialize(id:, open_time:, close_time:, open_timestamp:, close_timestamp:, uid:, request_id:, amount:, profit:, percent_profit:, percent_loss:, open_price:, close_price:, command:, asset:, is_demo:, copy_ticket:, open_ms:, close_ms:, option_type:, is_rollover:, is_copy_signal:, is_ai:, currency:, amount_usd:, amount_usd2:)
    @id = id
    @open_time = open_time
    @close_time = close_time
    @open_timestamp = open_timestamp
    @close_timestamp = close_timestamp
    @uid = uid
    @request_id = request_id
    @amount = amount
    @profit = profit
    @percent_profit = percent_profit
    @percent_loss = percent_loss
    @open_price = open_price
    @close_price = close_price
    @command = command
    @asset = asset
    @is_demo = is_demo
    @copy_ticket = copy_ticket
    @open_ms = open_ms
    @close_ms = close_ms
    @option_type = option_type
    @is_rollover = is_rollover
    @is_copy_signal = is_copy_signal
    @is_ai = is_ai
    @currency = currency
    @amount_usd = amount_usd
    @amount_usd2 = amount_usd2
  end

  def ==(other)
    if @id != other.id
      return false
    end
    if @open_time != other.open_time
      return false
    end
    if @close_time != other.close_time
      return false
    end
    if @open_timestamp != other.open_timestamp
      return false
    end
    if @close_timestamp != other.close_timestamp
      return false
    end
    if @uid != other.uid
      return false
    end
    if @request_id != other.request_id
      return false
    end
    if @amount != other.amount
      return false
    end
    if @profit != other.profit
      return false
    end
    if @percent_profit != other.percent_profit
      return false
    end
    if @percent_loss != other.percent_loss
      return false
    end
    if @open_price != other.open_price
      return false
    end
    if @close_price != other.close_price
      return false
    end
    if @command != other.command
      return false
    end
    if @asset != other.asset
      return false
    end
    if @is_demo != other.is_demo
      return false
    end
    if @copy_ticket != other.copy_ticket
      return false
    end
    if @open_ms != other.open_ms
      return false
    end
    if @close_ms != other.close_ms
      return false
    end
    if @option_type != other.option_type
      return false
    end
    if @is_rollover != other.is_rollover
      return false
    end
    if @is_copy_signal != other.is_copy_signal
      return false
    end
    if @is_ai != other.is_ai
      return false
    end
    if @currency != other.currency
      return false
    end
    if @amount_usd != other.amount_usd
      return false
    end
    if @amount_usd2 != other.amount_usd2
      return false
    end

    true
  end
end
  

  

  
  class PocketOption

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self.uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self.uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      BinaryOptionsToolsUni.rust_call(
        :uniffi_binary_options_tools_uni_fn_free_pocketoption,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self.uniffi_check_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a PocketOption instance, got #{inst}"
    end
  end

  def uniffi_clone_pointer()
    return BinaryOptionsToolsUni.rust_call(
      :uniffi_binary_options_tools_uni_fn_clone_pocketoption,
      @pointer
    )
  end

  def self.uniffi_lower(inst)
    return inst.uniffi_clone_pointer()
  end
  def initialize(ssid)
        ssid = BinaryOptionsToolsUni::uniffi_utf8(ssid)
        
    pointer = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new,RustBuffer.allocFromString(ssid))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class.uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  def self.init(ssid)
        ssid = BinaryOptionsToolsUni::uniffi_utf8(ssid)
        
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return uniffi_allocate(BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_constructor_pocketoption_init,RustBuffer.allocFromString(ssid)))
  end
  def self.new_with_url(ssid, url)
        ssid = BinaryOptionsToolsUni::uniffi_utf8(ssid)
        
        url = BinaryOptionsToolsUni::uniffi_utf8(url)
        
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return uniffi_allocate(BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_constructor_pocketoption_new_with_url,RustBuffer.allocFromString(ssid),RustBuffer.allocFromString(url)))
  end
  

  def assets()
    result = BinaryOptionsToolsUni.rust_call(:uniffi_binary_options_tools_uni_fn_method_pocketoption_assets,uniffi_clone_pointer(),)
    return result.consumeIntoOptionalSequenceTypeAsset
  end
  def balance()
    result = BinaryOptionsToolsUni.rust_call(:uniffi_binary_options_tools_uni_fn_method_pocketoption_balance,uniffi_clone_pointer(),)
    return result.to_f
  end
  def buy(asset, time, amount)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
        time = BinaryOptionsToolsUni::uniffi_in_range(time, "u32", 0, 2**32)
        
        amount = amount
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_buy,uniffi_clone_pointer(),RustBuffer.allocFromString(asset),time,amount)
    return result.consumeIntoTypeDeal
  end
  def clear_closed_deals()
      BinaryOptionsToolsUni.rust_call(:uniffi_binary_options_tools_uni_fn_method_pocketoption_clear_closed_deals,uniffi_clone_pointer(),)
  end
  
  def get_candles(asset, period, offset)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
        period = BinaryOptionsToolsUni::uniffi_in_range(period, "i64", -2**63, 2**63)
        
        offset = BinaryOptionsToolsUni::uniffi_in_range(offset, "i64", -2**63, 2**63)
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles,uniffi_clone_pointer(),RustBuffer.allocFromString(asset),period,offset)
    return result.consumeIntoSequenceTypeCandle
  end
  def get_candles_advanced(asset, period, time, offset)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
        period = BinaryOptionsToolsUni::uniffi_in_range(period, "i64", -2**63, 2**63)
        
        time = BinaryOptionsToolsUni::uniffi_in_range(time, "i64", -2**63, 2**63)
        
        offset = BinaryOptionsToolsUni::uniffi_in_range(offset, "i64", -2**63, 2**63)
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_get_candles_advanced,uniffi_clone_pointer(),RustBuffer.allocFromString(asset),period,time,offset)
    return result.consumeIntoSequenceTypeCandle
  end
  def get_closed_deals()
    result = BinaryOptionsToolsUni.rust_call(:uniffi_binary_options_tools_uni_fn_method_pocketoption_get_closed_deals,uniffi_clone_pointer(),)
    return result.consumeIntoSequenceTypeDeal
  end
  def get_opened_deals()
    result = BinaryOptionsToolsUni.rust_call(:uniffi_binary_options_tools_uni_fn_method_pocketoption_get_opened_deals,uniffi_clone_pointer(),)
    return result.consumeIntoSequenceTypeDeal
  end
  def history(asset, period)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
        period = BinaryOptionsToolsUni::uniffi_in_range(period, "u32", 0, 2**32)
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_history,uniffi_clone_pointer(),RustBuffer.allocFromString(asset),period)
    return result.consumeIntoSequenceTypeCandle
  end
  def is_demo()
    result = BinaryOptionsToolsUni.rust_call(:uniffi_binary_options_tools_uni_fn_method_pocketoption_is_demo,uniffi_clone_pointer(),)
    return 1 == result
  end
  def reconnect()
      BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_reconnect,uniffi_clone_pointer(),)
  end
  
  def result(id)
        id = BinaryOptionsToolsUni::uniffi_utf8(id)
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_result,uniffi_clone_pointer(),RustBuffer.allocFromString(id))
    return result.consumeIntoTypeDeal
  end
  def result_with_timeout(id, timeout_secs)
        id = BinaryOptionsToolsUni::uniffi_utf8(id)
        
        timeout_secs = BinaryOptionsToolsUni::uniffi_in_range(timeout_secs, "u64", 0, 2**64)
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_result_with_timeout,uniffi_clone_pointer(),RustBuffer.allocFromString(id),timeout_secs)
    return result.consumeIntoTypeDeal
  end
  def sell(asset, time, amount)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
        time = BinaryOptionsToolsUni::uniffi_in_range(time, "u32", 0, 2**32)
        
        amount = amount
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_sell,uniffi_clone_pointer(),RustBuffer.allocFromString(asset),time,amount)
    return result.consumeIntoTypeDeal
  end
  def server_time()
    result = BinaryOptionsToolsUni.rust_call(:uniffi_binary_options_tools_uni_fn_method_pocketoption_server_time,uniffi_clone_pointer(),)
    return result.to_i
  end
  def shutdown()
      BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_shutdown,uniffi_clone_pointer(),)
  end
  
  def subscribe(asset, duration_secs)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
        duration_secs = BinaryOptionsToolsUni::uniffi_in_range(duration_secs, "u64", 0, 2**64)
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_subscribe,uniffi_clone_pointer(),RustBuffer.allocFromString(asset),duration_secs)
    return SubscriptionStream.uniffi_allocate(result)
  end
  def trade(asset, action, time, amount)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
        action = action
        RustBuffer.check_lower_TypeAction(action)
        time = BinaryOptionsToolsUni::uniffi_in_range(time, "u32", 0, 2**32)
        
        amount = amount
        
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_trade,uniffi_clone_pointer(),RustBuffer.allocFromString(asset),RustBuffer.alloc_from_TypeAction(action),time,amount)
    return result.consumeIntoTypeDeal
  end
  def unsubscribe(asset)
        asset = BinaryOptionsToolsUni::uniffi_utf8(asset)
        
      BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_pocketoption_unsubscribe,uniffi_clone_pointer(),RustBuffer.allocFromString(asset))
  end
  
  
end
  
  class SubscriptionStream

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self.uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self.uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      BinaryOptionsToolsUni.rust_call(
        :uniffi_binary_options_tools_uni_fn_free_subscriptionstream,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self.uniffi_check_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a SubscriptionStream instance, got #{inst}"
    end
  end

  def uniffi_clone_pointer()
    return BinaryOptionsToolsUni.rust_call(
      :uniffi_binary_options_tools_uni_fn_clone_subscriptionstream,
      @pointer
    )
  end

  def self.uniffi_lower(inst)
    return inst.uniffi_clone_pointer()
  end

  

  def next()
    result = BinaryOptionsToolsUni.rust_call_with_error(UniError,:uniffi_binary_options_tools_uni_fn_method_subscriptionstream_next,uniffi_clone_pointer(),)
    return result.consumeIntoTypeCandle
  end
  
end
  
end

