/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export declare function startTracing(path: string, level: string, terminal: boolean, layers: Array<StreamLogsLayer>): void
export declare class StreamIterator {
  next(): Promise<string | null>
}
export declare class RawStreamIterator {
  next(): Promise<string | null>
}
/**
 * A client for interacting with the Pocket Option trading platform.
 * Provides methods for executing trades, managing positions, and streaming market data.
 *
 * # Examples
 * ```javascript
 * const client = new PocketOption("your-ssid-here");
 *
 * // Execute a buy order
 * const [orderId, details] = await client.buy("EUR/USD", 100, 60);
 *
 * // Check trade result
 * const result = await client.checkWin(orderId);
 * ```
 */
export declare class PocketOption {
  /**
   * Creates a new PocketOption client instance using a session ID.
   *
   * # Arguments
   * * `ssid` - A valid session ID string from Pocket Option
   *
   * # Examples
   * ```javascript
   * const client = new PocketOption("your-ssid-here");
   * ```
   */
  constructor(ssid: string)
  /**
   * Creates a new PocketOption client instance with a custom WebSocket URL.
   *
   * # Arguments
   * * `ssid` - A valid session ID string from Pocket Option
   * * `url` - Custom WebSocket server URL
   *
   * # Examples
   * ```javascript
   * const client = await PocketOption.newWithUrl(
   *     "your-ssid-here",
   *     "wss://custom-server.com/ws"
   * );
   * ```
   */
  static newWithUrl(ssid: string, url: string): Promise<PocketOption>
  /**
   * Executes a buy (CALL) order for a specified asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `amount` - The trade amount in account currency
   * * `time` - The option duration in seconds
   *
   * # Returns
   * A vector containing the order ID and order details as JSON strings
   *
   * # Examples
   * ```javascript
   * const [orderId, details] = await client.buy("EUR/USD", 100, 60);
   * console.log(`Order placed: ${orderId}`);
   * console.log(`Details: ${details}`);
   * ```
   */
  buy(asset: string, amount: number, time: number): Promise<Array<string>>
  /**
   * Executes a sell (PUT) order for a specified asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `amount` - The trade amount in account currency
   * * `time` - The option duration in seconds
   *
   * # Returns
   * A vector containing the order ID and order details as JSON strings
   *
   * # Examples
   * ```javascript
   * const [orderId, details] = await client.sell("EUR/USD", 100, 60);
   * console.log(`Order placed: ${orderId}`);
   * console.log(`Details: ${details}`);
   * ```
   */
  sell(asset: string, amount: number, time: number): Promise<Array<string>>
  /**
   * Checks the result of a trade by its ID.
   *
   * # Arguments
   * * `trade_id` - The UUID of the trade to check
   *
   * # Returns
   * A JSON string containing the trade result details
   *
   * # Examples
   * ```javascript
   * const result = await client.checkWin(tradeId);
   * const details = JSON.parse(result);
   * console.log(`Profit: ${details.profit}`);
   * ```
   */
  checkWin(tradeId: string): Promise<string>
  /**
   * Gets the expiration timestamp of a trade.
   *
   * # Arguments
   * * `trade_id` - The UUID of the trade
   *
   * # Returns
   * The Unix timestamp when the trade will expire, or null if not found
   *
   * # Examples
   * ```javascript
   * const endTime = await client.getDealEndTime(tradeId);
   * if (endTime) {
   *     console.log(`Trade expires at: ${new Date(endTime * 1000)}`);
   * }
   * ```
   */
  getDealEndTime(tradeId: string): Promise<number | null>
  /**
   * Retrieves historical candle data for an asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `period` - The candle period in seconds
   * * `offset` - Time offset for historical data
   *
   * # Returns
   * A JSON string containing the candle data
   *
   * # Examples
   * ```javascript
   * const candles = await client.getCandles("EUR/USD", 60, 0);
   * const data = JSON.parse(candles);
   * console.log(`Retrieved ${data.length} candles`);
   * ```
   */
  getCandles(asset: string, period: number, offset: number): Promise<string>
  /**
   * Retrieves the current account balance.
   *
   * # Returns
   * A JSON string containing the balance information
   *
   * # Examples
   * ```javascript
   * const balanceInfo = await client.balance();
   * const data = JSON.parse(balanceInfo);
   * console.log(`Current balance: ${data.balance}`);
   * ```
   */
  balance(): Promise<string>
  /**
   * Retrieves all closed deals/trades.
   *
   * # Returns
   * A JSON string containing the closed deals information
   *
   * # Examples
   * ```javascript
   * const deals = await client.closedDeals();
   * const data = JSON.parse(deals);
   * console.log(`Total closed deals: ${data.length}`);
   * ```
   */
  closedDeals(): Promise<string>
  /**
   * Clears the list of closed deals from memory.
   *
   * # Examples
   * ```javascript
   * await client.clearClosedDeals();
   * ```
   */
  clearClosedDeals(): Promise<void>
  /**
   * Retrieves all currently open deals/trades.
   *
   * # Returns
   * A JSON string containing the open deals information
   *
   * # Examples
   * ```javascript
   * const deals = await client.openedDeals();
   * const data = JSON.parse(deals);
   * console.log(`Total open positions: ${data.length}`);
   * ```
   */
  openedDeals(): Promise<string>
  /**
   * Retrieves the current payout rates for all assets.
   *
   * # Returns
   * A JSON string containing the payout information
   *
   * # Examples
   * ```javascript
   * const payoutInfo = await client.payout();
   * const rates = JSON.parse(payoutInfo);
   * console.log(`EUR/USD payout: ${rates["EUR/USD"]}%`);
   * ```
   */
  payout(): Promise<string>
  /**
   * Retrieves historical data for an asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `period` - The historical data period
   *
   * # Returns
   * A JSON string containing the historical data
   *
   * # Examples
   * ```javascript
   * const history = await client.history("EUR/USD", 60);
   * const data = JSON.parse(history);
   * console.log(`Retrieved ${data.length} historical records`);
   * ```
   */
  history(asset: string, period: number): Promise<string>
  /**
   * Subscribes to real-time price updates for a symbol.
   *
   * # Arguments
   * * `symbol` - The trading symbol to subscribe to (e.g., "EUR/USD")
   *
   * # Returns
   * A StreamIterator for receiving price updates
   *
   * # Examples
   * ```javascript
   * const stream = await client.subscribeSymbol("EUR/USD");
   * for await (const update of stream) {
   *     console.log(`New price: ${update.price}`);
   * }
   * ```
   */
  subscribeSymbol(symbol: string): Promise<StreamIterator>
  /**
   * Subscribes to symbol updates with chunked delivery.
   *
   * # Arguments
   * * `symbol` - The trading symbol to subscribe to (e.g., "EUR/USD")
   * * `chunk_size` - Number of updates to collect before delivery
   *
   * # Returns
   * A StreamIterator for receiving chunked price updates
   *
   * # Examples
   * ```javascript
   * const stream = await client.subscribeSymbolChunked("EUR/USD", 10);
   * for await (const updates of stream) {
   *     console.log(`Received batch of ${updates.length} updates`);
   * }
   * ```
   */
  subscribeSymbolChunked(symbol: string, chunkSize: number): Promise<StreamIterator>
  /**
   * Subscribes to symbol updates with time-based delivery.
   *
   * # Arguments
   * * `symbol` - The trading symbol to subscribe to (e.g., "EUR/USD")
   * * `time_seconds` - Time interval in seconds between updates
   *
   * # Returns
   * A StreamIterator for receiving time-based price updates
   *
   * # Examples
   * ```javascript
   * const stream = await client.subscribeSymbolTimed("EUR/USD", 5);
   * for await (const update of stream) {
   *     console.log(`Update at ${new Date()}: ${update.price}`);
   * }
   * ```
   */
  subscribeSymbolTimed(symbol: string, timeSeconds: number): Promise<StreamIterator>
}
/**
 * A validator for WebSocket messages that provides various matching strategies.
 *
 * # Examples
 * ```javascript
 * const validator = new Validator();
 * const regexValidator = Validator.regex("^Hello");
 * const containsValidator = Validator.contains("World");
 *
 * console.log(validator.check("Hello World")); // true
 * console.log(regexValidator.check("Hello World")); // true
 * console.log(containsValidator.check("Hello World")); // true
 * ```
 */
export declare class Validator {
  /**
   * Creates a new empty validator that matches any message.
   *
   * # Examples
   * ```javascript
   * const validator = new Validator();
   * console.log(validator.check("any message")); // true
   * ```
   */
  constructor()
  /**
   * Creates a new regex validator that matches messages using a regular expression pattern.
   *
   * # Arguments
   * * `pattern` - A string containing a valid regular expression pattern
   *
   * # Examples
   * ```javascript
   * const validator = Validator.regex("^Hello\\s\\w+");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("Hi World")); // false
   * ```
   */
  static regex(pattern: string): Validator
  /**
   * Creates a new validator that checks if a message contains the specified pattern.
   *
   * # Arguments
   * * `pattern` - The substring to search for in the message
   *
   * # Examples
   * ```javascript
   * const validator = Validator.contains("World");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("Hello")); // false
   * ```
   */
  static contains(pattern: string): Validator
  /**
   * Creates a new validator that checks if a message starts with the specified pattern.
   *
   * # Arguments
   * * `pattern` - The prefix to match at the start of the message
   *
   * # Examples
   * ```javascript
   * const validator = Validator.starts_with("Hello");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("World Hello")); // false
   * ```
   */
  static startsWith(pattern: string): Validator
  /**
   * Creates a new validator that checks if a message ends with the specified pattern.
   *
   * # Arguments
   * * `pattern` - The suffix to match at the end of the message
   *
   * # Examples
   * ```javascript
   * const validator = Validator.ends_with("World");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("World Hello")); // false
   * ```
   */
  static endsWith(pattern: string): Validator
  /**
   * Creates a new validator that negates the result of another validator.
   *
   * # Arguments
   * * `validator` - The validator whose result should be negated
   *
   * # Examples
   * ```javascript
   * const contains = Validator.contains("World");
   * const notContains = Validator.ne(contains);
   * console.log(notContains.check("Hello Universe")); // true
   * console.log(notContains.check("Hello World")); // false
   * ```
   */
  static ne(validator: Validator): Validator
  /**
   * Creates a new validator that requires all provided validators to match.
   *
   * # Arguments
   * * `validators` - An array of validators that must all match for this validator to match
   *
   * # Examples
   * ```javascript
   * const startsHello = Validator.starts_with("Hello");
   * const endsWorld = Validator.ends_with("World");
   * const both = Validator.all([startsHello, endsWorld]);
   * console.log(both.check("Hello Beautiful World")); // true
   * console.log(both.check("Hello Universe")); // false
   * ```
   */
  static all(validators: Array<Validator>): Validator
  /**
   * Creates a new validator that requires at least one of the provided validators to match.
   *
   * # Arguments
   * * `validators` - An array of validators where at least one must match for this validator to match
   *
   * # Examples
   * ```javascript
   * const containsHello = Validator.contains("Hello");
   * const containsHi = Validator.contains("Hi");
   * const either = Validator.any([containsHello, containsHi]);
   * console.log(either.check("Hello World")); // true
   * console.log(either.check("Hi there")); // true
   * console.log(either.check("Hey there")); // false
   * ```
   */
  static any(validators: Array<Validator>): Validator
  static or(val1: Validator, val2: Validator): Validator
  static xor(val1: Validator, val2: Validator): Validator
  /**
   * Checks if a message matches this validator's conditions.
   *
   * # Arguments
   * * `msg` - The message string to validate
   *
   * # Returns
   * * `true` if the message matches the validator's conditions
   * * `false` otherwise
   *
   * # Examples
   * ```javascript
   * const validator = Validator.contains("World");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("Hello Universe")); // false
   * ```
   */
  check(msg: string): boolean
}
export declare class StreamLogsLayer { }
export declare class StreamLogsIterator {
  next(): Promise<string | null>
}
export declare class LogBuilder {
  constructor()
  createLogsIterator(level: string, timeout?: number | undefined | null): StreamLogsIterator
  logFile(path: string, level: string): void
  terminal(level: string): void
  build(): void
}
export declare class Logger {
  constructor()
  debug(message: string): void
  info(message: string): void
  warn(message: string): void
  error(message: string): void
}
