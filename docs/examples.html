<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examples - BinaryOptionsToolsV2</title>
    <meta name="description" content="Comprehensive examples for BinaryOptionsToolsV2 in Python, JavaScript, and Rust">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/animations.css">    <link rel="stylesheet" href="assets/css/code-highlight.css">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <h2>BinaryOptionsToolsV2</h2>
            </div>
            <div class="nav-toggle" id="mobile-menu">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">Home</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link dropdown-toggle">Languages</a>
                    <ul class="dropdown-menu">
                        <li><a href="python.html">Python</a></li>
                        <li><a href="javascript.html">JavaScript</a></li>
                        <li><a href="rust.html">Rust</a></li>
                    </ul>
                </li>
                <li class="nav-item">
                    <a href="examples.html" class="nav-link active">Examples</a>
                </li>
                <li class="nav-item">
                    <a href="api.html" class="nav-link">API Reference</a>
                </li>
                <li class="nav-item">
                    <a href="https://chipa.tech" class="nav-link btn-outline" target="_blank">Bot Services</a>
                </li>
            </ul>
        </div>
    </nav>

    <main>
        <section class="hero-section examples-hero">
            <div class="container">
                <div class="hero-content fade-in-up">
                    <h1>Examples & Tutorials</h1>
                    <p class="hero-subtitle">Comprehensive examples for all programming languages</p>
                    <div class="hero-badges">
                        <span class="badge">Python</span>
                        <span class="badge">JavaScript</span>
                        <span class="badge">Rust</span>
                        <span class="badge">Real Examples</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Language Selection -->
        <section class="language-selector">
            <div class="container">
                <div class="language-tabs fade-in-up">
                    <button class="lang-tab active" data-lang="python">
                        <div class="lang-icon">üêç</div>
                        <span>Python</span>
                    </button>
                    <button class="lang-tab" data-lang="javascript">
                        <div class="lang-icon">üìú</div>
                        <span>JavaScript</span>
                    </button>
                    <button class="lang-tab" data-lang="rust">
                        <div class="lang-icon">ü¶Ä</div>
                        <span>Rust</span>
                    </button>
                </div>
            </div>
        </section>

        <!-- Python Examples -->
        <section id="python" class="lang-content active">
            <div class="container">
                <div class="section-header fade-in-up">
                    <h2>Python Examples</h2>
                    <p>Practical Python examples for binary options trading</p>
                </div>

                <div class="examples-grid">
                    <!-- Basic Operations -->
                    <div class="example-card fade-in-up stagger-1">
                        <div class="example-header">
                            <h3>Basic Operations</h3>
                            <span class="example-type">Beginner</span>
                        </div>
                        <p>Get balance, place orders, and check results</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">python</span>
                                <button class="copy-btn" data-clipboard-target="#python-basic">Copy</button>
                            </div>
                            <pre><code id="python-basic">from BinaryOptionsToolsV2 import PocketOption

# Initialize client
client = PocketOption(ssid="your_ssid_here")

# Get account balance
balance = client.get_balance()
print(f"Current balance: ${balance:.2f}")

# Get candles for analysis
candles = client.get_candles("EURUSD_otc", 60, 50)
print(f"Retrieved {len(candles)} candles")

# Place a simple order
order = client.create_raw_order(
    asset="EURUSD_otc",
    amount=10.0,
    action="call",
    expiration=60
)

if order.success:
    print(f"Order placed! ID: {order.order_id}")
    
    # Wait for order to complete
    import time
    time.sleep(65)
    
    # Check result
    result = client.check_win(order.order_id)
    print(f"Order result: {result}")
else:
    print(f"Order failed: {order.message}")</code></pre>
                        </div>
                    </div>

                    <!-- Async Streaming -->
                    <div class="example-card fade-in-up stagger-2">
                        <div class="example-header">
                            <h3>Async Streaming</h3>
                            <span class="example-type">Intermediate</span>
                        </div>
                        <p>Real-time data streaming with async/await</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">python</span>
                                <button class="copy-btn" data-clipboard-target="#python-async">Copy</button>
                            </div>
                            <pre><code id="python-async">import asyncio
from BinaryOptionsToolsV2 import AsyncPocketOption

async def stream_candles():
    client = AsyncPocketOption(ssid="your_ssid_here")
    
    print("Starting candle stream...")
    
    # Stream candles for multiple assets
    assets = ["EURUSD_otc", "GBPUSD_otc", "USDJPY_otc"]
    
    async def handle_asset(asset):
        async for candle in client.stream_candles(asset, 60):
            print(f"{asset}: {candle.close} (Volume: {candle.volume})")
            
            # Simple trading logic
            if candle.volume > 1000:
                await place_order_if_signal(client, asset, candle)
    
    # Stream multiple assets concurrently
    tasks = [handle_asset(asset) for asset in assets]
    await asyncio.gather(*tasks)

async def place_order_if_signal(client, asset, candle):
    """Place order based on simple signal"""
    # Example: Buy if closing higher than opening
    if candle.close > candle.open:
        try:
            order = await client.create_raw_order(
                asset=asset,
                amount=5.0,
                action="call",
                expiration=60
            )
            print(f"üìà Placed CALL order for {asset}: {order.order_id}")
        except Exception as e:
            print(f"‚ùå Order failed: {e}")

# Run the async function
asyncio.run(stream_candles())</code></pre>
                        </div>
                    </div>

                    <!-- Trading Bot -->
                    <div class="example-card fade-in-up stagger-3">
                        <div class="example-header">
                            <h3>Trading Bot</h3>
                            <span class="example-type">Advanced</span>
                        </div>
                        <p>Complete trading bot with risk management</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">python</span>
                                <button class="copy-btn" data-clipboard-target="#python-bot">Copy</button>
                            </div>
                            <pre><code id="python-bot">import asyncio
import logging
from datetime import datetime, timedelta
from dataclasses import dataclass
from typing import Dict, List
from BinaryOptionsToolsV2 import AsyncPocketOption

@dataclass
class TradingConfig:
    max_concurrent_orders: int = 3
    risk_per_trade: float = 2.0  # Percentage of balance
    min_volume_threshold: float = 1000.0
    assets: List[str] = None

    def __post_init__(self):
        if self.assets is None:
            self.assets = ["EURUSD_otc", "GBPUSD_otc", "USDJPY_otc"]

class TradingBot:
    def __init__(self, ssid: str, config: TradingConfig):
        self.client = AsyncPocketOption(ssid)
        self.config = config
        self.active_orders: Dict[str, dict] = {}
        self.balance = 0.0
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    async def start(self):
        """Start the trading bot"""
        self.logger.info("üöÄ Trading bot starting...")
        
        # Get initial balance
        self.balance = await self.client.get_balance()
        self.logger.info(f"üí∞ Initial balance: ${self.balance:.2f}")
        
        # Start monitoring orders and streaming data
        await asyncio.gather(
            self.monitor_orders(),
            self.stream_market_data()
        )

    async def stream_market_data(self):
        """Stream market data for all configured assets"""
        async def handle_asset_stream(asset):
            try:
                async for candle in self.client.stream_candles(asset, 60):
                    await self.analyze_candle(asset, candle)
            except Exception as e:
                self.logger.error(f"Stream error for {asset}: {e}")

        # Start streaming for all assets
        tasks = [handle_asset_stream(asset) for asset in self.config.assets]
        await asyncio.gather(*tasks, return_exceptions=True)

    async def analyze_candle(self, asset: str, candle):
        """Analyze candle and decide whether to trade"""
        # Check if we can place more orders
        if len(self.active_orders) >= self.config.max_concurrent_orders:
            return

        # Simple strategy: high volume + price movement
        price_change = abs(candle.close - candle.open) / candle.open * 100
        
        if (candle.volume > self.config.min_volume_threshold and 
            price_change > 0.1):
            
            # Determine direction
            action = "call" if candle.close > candle.open else "put"
            
            # Calculate position size
            amount = self.calculate_position_size()
            
            await self.place_order(asset, amount, action)

    def calculate_position_size(self) -> float:
        """Calculate position size based on risk management"""
        risk_amount = self.balance * (self.config.risk_per_trade / 100)
        return max(1.0, min(risk_amount, 50.0))  # Min $1, Max $50

    async def place_order(self, asset: str, amount: float, action: str):
        """Place a trading order"""
        try:
            order = await self.client.create_raw_order(
                asset=asset,
                amount=amount,
                action=action,
                expiration=60
            )
            
            if order.success:
                self.active_orders[order.order_id] = {
                    'asset': asset,
                    'amount': amount,
                    'action': action,
                    'timestamp': datetime.now()
                }
                
                self.logger.info(
                    f"üìä Order placed: {asset} {action.upper()} "
                    f"${amount:.2f} (ID: {order.order_id})"
                )
            else:
                self.logger.error(f"‚ùå Order failed: {order.message}")
                
        except Exception as e:
            self.logger.error(f"Order placement error: {e}")

    async def monitor_orders(self):
        """Monitor active orders and update results"""
        while True:
            if not self.active_orders:
                await asyncio.sleep(5)
                continue
                
            completed_orders = []
            
            for order_id, order_info in self.active_orders.items():
                # Check if order should be completed (after 60+ seconds)
                if datetime.now() - order_info['timestamp'] > timedelta(seconds=65):
                    try:
                        result = await self.client.check_win(order_id)
                        
                        if result != "pending":
                            completed_orders.append(order_id)
                            await self.handle_order_result(order_id, order_info, result)
                            
                    except Exception as e:
                        self.logger.error(f"Error checking order {order_id}: {e}")
            
            # Remove completed orders
            for order_id in completed_orders:
                del self.active_orders[order_id]
            
            # Update balance periodically
            try:
                self.balance = await self.client.get_balance()
            except Exception as e:
                self.logger.error(f"Error updating balance: {e}")
            
            await asyncio.sleep(10)

    async def handle_order_result(self, order_id: str, order_info: dict, result: str):
        """Handle completed order result"""
        asset = order_info['asset']
        amount = order_info['amount']
        action = order_info['action']
        
        if result == "win":
            profit = amount * 0.8  # Assuming 80% payout
            self.logger.info(
                f"‚úÖ WIN: {asset} {action.upper()} +${profit:.2f} "
                f"(Balance: ${self.balance:.2f})"
            )
        else:
            self.logger.info(
                f"‚ùå LOSS: {asset} {action.upper()} -${amount:.2f} "
                f"(Balance: ${self.balance:.2f})"
            )

# Usage example
async def main():
    config = TradingConfig(
        max_concurrent_orders=2,
        risk_per_trade=1.5,
        assets=["EURUSD_otc", "GBPUSD_otc"]
    )
    
    bot = TradingBot(ssid="your_ssid_here", config=config)
    await bot.start()

if __name__ == "__main__":
    asyncio.run(main())</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- JavaScript Examples -->
        <section id="javascript" class="lang-content">
            <div class="container">
                <div class="section-header fade-in-up">
                    <h2>JavaScript Examples</h2>
                    <p>Practical JavaScript examples for Node.js and browser environments</p>
                </div>

                <div class="examples-grid">
                    <!-- Basic Node.js -->
                    <div class="example-card fade-in-up stagger-1">
                        <div class="example-header">
                            <h3>Basic Node.js Usage</h3>
                            <span class="example-type">Beginner</span>
                        </div>
                        <p>Simple trading operations in Node.js</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">javascript</span>
                                <button class="copy-btn" data-clipboard-target="#js-basic">Copy</button>
                            </div>
                            <pre><code id="js-basic">const { PocketOption } = require('binaryoptionstools-v2');

async function main() {
    // Initialize the API client
    const api = new PocketOption('your_ssid_here');
    
    // Wait for connection to establish
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    try {
        // Get account balance
        const balance = await api.getBalance();
        console.log(`üí∞ Balance: $${balance.toFixed(2)}`);
        
        // Get recent candles for analysis
        const candles = await api.getCandles('EURUSD_otc', 60, 20);
        console.log(`üìä Retrieved ${candles.length} candles`);
        
        // Analyze last candle
        const lastCandle = candles[candles.length - 1];
        console.log(`üìà Last candle: Open=${lastCandle.open}, Close=${lastCandle.close}`);
        
        // Place order based on simple logic
        const action = lastCandle.close > lastCandle.open ? 'call' : 'put';
        const orderResult = await api.createRawOrder({
            asset: 'EURUSD_otc',
            amount: 10.0,
            action: action,
            expiration: 60
        });
        
        if (orderResult.success) {
            console.log(`‚úÖ Order placed: ${action.toUpperCase()} (ID: ${orderResult.orderId})`);
            
            // Wait for order completion
            setTimeout(async () => {
                try {
                    const result = await api.checkWin(orderResult.orderId);
                    console.log(`üéØ Order result: ${result}`);
                } catch (error) {
                    console.error('Error checking result:', error.message);
                }
            }, 65000);
            
        } else {
            console.error(`‚ùå Order failed: ${orderResult.message}`);
        }
        
    } catch (error) {
        console.error('Error:', error.message);
    }
}

main().catch(console.error);</code></pre>
                        </div>
                    </div>

                    <!-- Real-time Stream -->
                    <div class="example-card fade-in-up stagger-2">
                        <div class="example-header">
                            <h3>Real-time Data Stream</h3>
                            <span class="example-type">Intermediate</span>
                        </div>
                        <p>Stream live market data with event handling</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">javascript</span>
                                <button class="copy-btn" data-clipboard-target="#js-stream">Copy</button>
                            </div>
                            <pre><code id="js-stream">const { PocketOption } = require('binaryoptionstools-v2');
const EventEmitter = require('events');

class MarketDataStreamer extends EventEmitter {
    constructor(ssid) {
        super();
        this.api = new PocketOption(ssid);
        this.activeStreams = new Map();
        this.candleBuffer = new Map();
    }

    async initialize() {
        // Wait for connection
        await new Promise(resolve => setTimeout(resolve, 5000));
        console.log('üîó Connected to PocketOption');
    }

    async subscribeToAsset(asset, timeframe = 60) {
        try {
            console.log(`üìä Subscribing to ${asset} (${timeframe}s)`);
            
            // Subscribe to symbol stream
            const stream = await this.api.subscribeSymbol(asset);
            this.activeStreams.set(asset, stream);
            
            // Process stream data
            this.processStream(asset, stream);
            
        } catch (error) {
            console.error(`Error subscribing to ${asset}:`, error.message);
            this.emit('error', { asset, error });
        }
    }

    async processStream(asset, stream) {
        try {
            for await (const data of stream) {
                // Emit raw data
                this.emit('tick', { asset, data });
                
                // Buffer candle data
                this.bufferCandleData(asset, data);
                
                // Check for trading signals
                this.analyzeData(asset, data);
            }
        } catch (error) {
            console.error(`Stream error for ${asset}:`, error);
            this.emit('streamError', { asset, error });
            
            // Attempt to reconnect after delay
            setTimeout(() => {
                console.log(`üîÑ Reconnecting to ${asset}...`);
                this.subscribeToAsset(asset);
            }, 5000);
        }
    }

    bufferCandleData(asset, data) {
        if (!this.candleBuffer.has(asset)) {
            this.candleBuffer.set(asset, []);
        }
        
        const buffer = this.candleBuffer.get(asset);
        buffer.push({
            timestamp: Date.now(),
            price: data.price || data.close,
            volume: data.volume || 0,
            ...data
        });
        
        // Keep only last 50 data points
        if (buffer.length > 50) {
            buffer.shift();
        }
    }

    analyzeData(asset, data) {
        const buffer = this.candleBuffer.get(asset) || [];
        if (buffer.length < 10) return; // Need minimum data
        
        const recentPrices = buffer.slice(-10).map(d => d.price);
        const currentPrice = data.price || data.close;
        const avgPrice = recentPrices.reduce((a, b) => a + b) / recentPrices.length;
        
        // Simple momentum strategy
        const momentum = (currentPrice - avgPrice) / avgPrice * 100;
        
        if (Math.abs(momentum) > 0.1) { // 0.1% threshold
            this.emit('signal', {
                asset,
                action: momentum > 0 ? 'call' : 'put',
                strength: Math.abs(momentum),
                price: currentPrice,
                timestamp: Date.now()
            });
        }
    }

    async unsubscribe(asset) {
        const stream = this.activeStreams.get(asset);
        if (stream && stream.return) {
            await stream.return();
        }
        this.activeStreams.delete(asset);
        this.candleBuffer.delete(asset);
        console.log(`‚ùå Unsubscribed from ${asset}`);
    }

    async cleanup() {
        console.log('üßπ Cleaning up streams...');
        for (const [asset] of this.activeStreams) {
            await this.unsubscribe(asset);
        }
    }
}

// Usage example
async function main() {
    const streamer = new MarketDataStreamer('your_ssid_here');
    
    // Event listeners
    streamer.on('tick', ({ asset, data }) => {
        console.log(`üìà ${asset}: ${data.price || data.close}`);
    });
    
    streamer.on('signal', async ({ asset, action, strength, price }) => {
        console.log(`üö® Signal: ${asset} ${action.toUpperCase()} (${strength.toFixed(3)}% @ ${price})`);
        
        // Optional: Place order on signal
        // await placeOrder(asset, action, 5.0);
    });
    
    streamer.on('error', ({ asset, error }) => {
        console.error(`‚ùå ${asset} error:`, error.message);
    });
    
    // Initialize and subscribe
    await streamer.initialize();
    await streamer.subscribeToAsset('EURUSD_otc');
    await streamer.subscribeToAsset('GBPUSD_otc');
    
    // Run for 5 minutes then cleanup
    setTimeout(async () => {
        await streamer.cleanup();
        console.log('‚úÖ Demo completed');
        process.exit(0);
    }, 300000); // 5 minutes
}

main().catch(console.error);</code></pre>
                        </div>
                    </div>

                    <!-- Browser Trading App -->
                    <div class="example-card fade-in-up stagger-3">
                        <div class="example-header">
                            <h3>Browser Trading App</h3>
                            <span class="example-type">Advanced</span>
                        </div>
                        <p>Complete trading interface for web browsers</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">html</span>
                                <button class="copy-btn" data-clipboard-target="#js-browser">Copy</button>
                            </div>
                            <pre><code id="js-browser">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Binary Options Trader&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/binaryoptionstools-v2@latest/dist/index.min.js"&gt;&lt;/script&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a2e; color: white; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { display: flex; justify-content: between; align-items: center; margin-bottom: 20px; }
        .balance { font-size: 24px; font-weight: bold; color: #4CAF50; }
        .trading-panel { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .chart-container { background: #16213e; padding: 20px; border-radius: 10px; }
        .controls { background: #16213e; padding: 20px; border-radius: 10px; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input, .control-group select { 
            width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #333; 
            background: #0f172a; color: white; 
        }
        .btn { 
            padding: 10px 20px; border: none; border-radius: 5px; 
            cursor: pointer; font-size: 16px; margin: 5px; 
        }
        .btn-call { background: #4CAF50; color: white; }
        .btn-put { background: #f44336; color: white; }
        .btn:hover { opacity: 0.8; }
        .orders { margin-top: 20px; }
        .order { 
            background: #16213e; padding: 10px; margin: 5px 0; 
            border-radius: 5px; border-left: 4px solid #2196F3; 
        }
        .status { margin-top: 20px; padding: 10px; border-radius: 5px; }
        .status.connected { background: #4CAF50; }
        .status.error { background: #f44336; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;Binary Options Trader&lt;/h1&gt;
            &lt;div class="balance" id="balance"&gt;Balance: $0.00&lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="status" id="status"&gt;Connecting...&lt;/div&gt;
        
        &lt;div class="trading-panel"&gt;
            &lt;div class="chart-container"&gt;
                &lt;canvas id="priceChart" width="800" height="400"&gt;&lt;/canvas&gt;
            &lt;/div&gt;
            
            &lt;div class="controls"&gt;
                &lt;div class="control-group"&gt;
                    &lt;label&gt;Asset:&lt;/label&gt;
                    &lt;select id="assetSelect"&gt;
                        &lt;option value="EURUSD_otc"&gt;EUR/USD OTC&lt;/option&gt;
                        &lt;option value="GBPUSD_otc"&gt;GBP/USD OTC&lt;/option&gt;
                        &lt;option value="USDJPY_otc"&gt;USD/JPY OTC&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                
                &lt;div class="control-group"&gt;
                    &lt;label&gt;Amount ($):&lt;/label&gt;
                    &lt;input type="number" id="amountInput" value="10" step="1" min="1"&gt;
                &lt;/div&gt;
                
                &lt;div class="control-group"&gt;
                    &lt;label&gt;Expiration (seconds):&lt;/label&gt;
                    &lt;select id="expirationSelect"&gt;
                        &lt;option value="60"&gt;1 minute&lt;/option&gt;
                        &lt;option value="120"&gt;2 minutes&lt;/option&gt;
                        &lt;option value="300"&gt;5 minutes&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                
                &lt;div style="text-align: center;"&gt;
                    &lt;button class="btn btn-call" id="callBtn"&gt;üìà CALL&lt;/button&gt;
                    &lt;button class="btn btn-put" id="putBtn"&gt;üìâ PUT&lt;/button&gt;
                &lt;/div&gt;
                
                &lt;div class="control-group"&gt;
                    &lt;label&gt;Current Price: &lt;span id="currentPrice"&gt;-.----&lt;/span&gt;&lt;/label&gt;
                    &lt;label&gt;Trend: &lt;span id="trend"&gt;-&lt;/span&gt;&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="orders"&gt;
            &lt;h3&gt;Active Orders&lt;/h3&gt;
            &lt;div id="ordersList"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        class TradingApp {
            constructor() {
                this.client = null;
                this.chart = null;
                this.priceData = [];
                this.activeOrders = new Map();
                this.currentAsset = 'EURUSD_otc';
                
                this.initializeChart();
                this.bindEvents();
                this.initialize();
            }

            async initialize() {
                try {
                    // Initialize client
                    this.client = new BinaryOptionsToolsV2.PocketOption({
                        ssid: prompt('Enter your SSID:') || 'demo_ssid'
                    });
                    
                    await this.connect();
                    this.updateStatus('Connected', 'connected');
                    
                    // Start data stream
                    this.startDataStream();
                    
                    // Update balance
                    await this.updateBalance();
                    
                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`, 'error');
                }
            }

            async connect() {
                // Wait for connection
                await new Promise(resolve => setTimeout(resolve, 3000));
            }

            updateStatus(message, type = '') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            async updateBalance() {
                try {
                    const balance = await this.client.getBalance();
                    document.getElementById('balance').textContent = `Balance: $${balance.toFixed(2)}`;
                } catch (error) {
                    console.error('Balance update error:', error);
                }
            }

            initializeChart() {
                const ctx = document.getElementById('priceChart').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Price',
                            data: [],
                            borderColor: '#2196F3',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { labels: { color: 'white' } }
                        },
                        scales: {
                            x: { ticks: { color: 'white' }, grid: { color: '#333' } },
                            y: { ticks: { color: 'white' }, grid: { color: '#333' } }
                        }
                    }
                });
            }

            async startDataStream() {
                try {
                    const stream = await this.client.subscribeSymbol(this.currentAsset);
                    
                    for await (const data of stream) {
                        this.updatePriceData(data);
                    }
                } catch (error) {
                    console.error('Stream error:', error);
                    setTimeout(() => this.startDataStream(), 5000);
                }
            }

            updatePriceData(data) {
                const price = data.price || data.close || Math.random() * 1.2 + 1.1;
                const time = new Date().toLocaleTimeString();
                
                this.priceData.push({ time, price });
                if (this.priceData.length > 50) {
                    this.priceData.shift();
                }
                
                // Update chart
                this.chart.data.labels = this.priceData.map(d => d.time);
                this.chart.data.datasets[0].data = this.priceData.map(d => d.price);
                this.chart.update('none');
                
                // Update current price
                document.getElementById('currentPrice').textContent = price.toFixed(5);
                
                // Update trend
                if (this.priceData.length > 1) {
                    const prev = this.priceData[this.priceData.length - 2].price;
                    const trend = price > prev ? 'üìà UP' : price < prev ? 'üìâ DOWN' : '‚û°Ô∏è FLAT';
                    document.getElementById('trend').textContent = trend;
                }
            }

            bindEvents() {
                document.getElementById('callBtn').addEventListener('click', () => this.placeOrder('call'));
                document.getElementById('putBtn').addEventListener('click', () => this.placeOrder('put'));
                
                document.getElementById('assetSelect').addEventListener('change', (e) => {
                    this.currentAsset = e.target.value;
                    this.startDataStream();
                });
            }

            async placeOrder(action) {
                const amount = parseFloat(document.getElementById('amountInput').value);
                const expiration = parseInt(document.getElementById('expirationSelect').value);
                
                if (!amount || amount < 1) {
                    alert('Please enter a valid amount');
                    return;
                }
                
                try {
                    const order = await this.client.createRawOrder({
                        asset: this.currentAsset,
                        amount: amount,
                        action: action,
                        expiration: expiration
                    });
                    
                    if (order.success) {
                        this.addOrder(order.orderId, {
                            asset: this.currentAsset,
                            amount: amount,
                            action: action,
                            expiration: expiration,
                            timestamp: Date.now()
                        });
                        
                        await this.updateBalance();
                    } else {
                        alert(`Order failed: ${order.message}`);
                    }
                } catch (error) {
                    alert(`Error placing order: ${error.message}`);
                }
            }

            addOrder(orderId, orderInfo) {
                this.activeOrders.set(orderId, orderInfo);
                
                const orderDiv = document.createElement('div');
                orderDiv.className = 'order';
                orderDiv.id = `order-${orderId}`;
                orderDiv.innerHTML = `
                    &lt;strong&gt;${orderInfo.asset}&lt;/strong&gt; 
                    ${orderInfo.action.toUpperCase()} 
                    $${orderInfo.amount} 
                    (${orderInfo.expiration}s)
                    &lt;span style="float: right;"&gt;‚è≥ Pending&lt;/span&gt;
                `;
                
                document.getElementById('ordersList').appendChild(orderDiv);
                
                // Check result after expiration
                setTimeout(async () => {
                    await this.checkOrderResult(orderId);
                }, (orderInfo.expiration + 5) * 1000);
            }

            async checkOrderResult(orderId) {
                try {
                    const result = await this.client.checkWin(orderId);
                    const orderDiv = document.getElementById(`order-${orderId}`);
                    
                    if (orderDiv) {
                        const status = result === 'win' ? '‚úÖ WIN' : result === 'lose' ? '‚ùå LOSS' : '‚è≥ Pending';
                        const color = result === 'win' ? '#4CAF50' : result === 'lose' ? '#f44336' : '#2196F3';
                        
                        orderDiv.style.borderLeftColor = color;
                        orderDiv.querySelector('span').textContent = status;
                        
                        if (result !== 'pending') {
                            this.activeOrders.delete(orderId);
                            await this.updateBalance();
                        }
                    }
                } catch (error) {
                    console.error(`Error checking order ${orderId}:`, error);
                }
            }
        }

        // Initialize the trading app
        window.addEventListener('load', () => {
            new TradingApp();
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Rust Examples -->
        <section id="rust" class="lang-content">
            <div class="container">
                <div class="section-header fade-in-up">
                    <h2>Rust Examples</h2>
                    <p>High-performance Rust examples for professional trading</p>
                </div>

                <div class="examples-grid">
                    <!-- Basic Rust -->
                    <div class="example-card fade-in-up stagger-1">
                        <div class="example-header">
                            <h3>Basic Trading</h3>
                            <span class="example-type">Beginner</span>
                        </div>
                        <p>Basic trading operations with error handling</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">rust</span>
                                <button class="copy-btn" data-clipboard-target="#rust-basic">Copy</button>
                            </div>
                            <pre><code id="rust-basic">use binary_options_tools_v2::{
    PocketOption, OrderOptions, Result, Error, ErrorKind
};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize client with error handling
    let client = match PocketOption::new("your_ssid_here").await {
        Ok(client) => {
            println!("‚úÖ Connected to PocketOption");
            client
        }
        Err(e) => {
            eprintln!("‚ùå Connection failed: {}", e);
            return Err(e);
        }
    };

    // Get account balance
    match client.get_balance().await {
        Ok(balance) => println!("üí∞ Balance: ${:.2}", balance),
        Err(e) => eprintln!("Error getting balance: {}", e),
    }

    // Get candles for analysis
    let candles = client.get_candles("EURUSD_otc", 60, 20).await?;
    println!("üìä Retrieved {} candles", candles.len());

    // Analyze trend
    if let (Some(first), Some(last)) = (candles.first(), candles.last()) {
        let trend = if last.close > first.close { "üìà Uptrend" } else { "üìâ Downtrend" };
        println!("Trend analysis: {}", trend);

        // Place order based on trend
        let action = if last.close > first.close { "call" } else { "put" };
        
        let order_options = OrderOptions {
            asset: "EURUSD_otc".to_string(),
            amount: 10.0,
            action: action.to_string(),
            expiration: 60,
        };

        match client.create_raw_order(order_options).await {
            Ok(order_result) => {
                if order_result.success {
                    println!("‚úÖ Order placed: {} (ID: {})", action.to_uppercase(), order_result.order_id);
                    
                    // Wait for order completion
                    tokio::time::sleep(tokio::time::Duration::from_secs(65)).await;
                    
                    // Check result
                    match client.check_win(&order_result.order_id).await {
                        Ok(result) => println!("üéØ Order result: {:?}", result),
                        Err(e) => eprintln!("Error checking result: {}", e),
                    }
                } else {
                    eprintln!("‚ùå Order failed: {}", order_result.message);
                }
            }
            Err(e) => eprintln!("Error placing order: {}", e),
        }
    }

    Ok(())
}</code></pre>
                        </div>
                    </div>

                    <!-- High-Performance Stream -->
                    <div class="example-card fade-in-up stagger-2">
                        <div class="example-header">
                            <h3>High-Performance Streaming</h3>
                            <span class="example-type">Intermediate</span>
                        </div>
                        <p>Concurrent streams with advanced processing</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">rust</span>
                                <button class="copy-btn" data-clipboard-target="#rust-stream">Copy</button>
                            </div>
                            <pre><code id="rust-stream">use binary_options_tools_v2::{PocketOption, StreamEvent, OrderOptions};
use futures::{StreamExt, stream::SelectAll};
use tokio::sync::mpsc;
use std::collections::HashMap;
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
struct MarketData {
    asset: String,
    price: f64,
    timestamp: Instant,
    volume: f64,
}

#[derive(Debug)]
struct TradingSignal {
    asset: String,
    action: String,
    strength: f64,
    price: f64,
}

struct HighPerformanceTrader {
    client: PocketOption,
    price_buffer: HashMap<String, Vec<MarketData>>,
    signal_sender: mpsc::UnboundedSender<TradingSignal>,
}

impl HighPerformanceTrader {
    async fn new(ssid: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let client = PocketOption::new(ssid).await?;
        let (signal_sender, _) = mpsc::unbounded_channel();
        
        Ok(Self {
            client,
            price_buffer: HashMap::new(),
            signal_sender,
        })
    }

    async fn start_multi_asset_streaming(&mut self, assets: Vec<&str>) -> Result<(), Box<dyn std::error::Error>> {
        // Create streams for all assets
        let mut streams = SelectAll::new();
        
        for asset in assets {
            match self.client.stream_candles(asset, 60).await {
                Ok(stream) => {
                    let asset_stream = stream.map(move |event| (asset.to_string(), event));
                    streams.push(asset_stream);
                    println!("üìä Started stream for {}", asset);
                }
                Err(e) => eprintln!("Failed to start stream for {}: {}", asset, e),
            }
        }

        // Set up signal processing
        let mut signal_receiver = self.setup_signal_processor().await;

        // Process streams concurrently
        tokio::select! {
            _ = self.process_market_streams(streams) => {},
            _ = self.process_trading_signals(&mut signal_receiver) => {},
        }

        Ok(())
    }

    async fn process_market_streams(&mut self, mut streams: SelectAll<impl futures::Stream<Item = (String, Result<StreamEvent, binary_options_tools_v2::Error>)> + Unpin>) {
        while let Some((asset, event_result)) = streams.next().await {
            match event_result {
                Ok(StreamEvent::Candle(candle)) => {
                    let market_data = MarketData {
                        asset: asset.clone(),
                        price: candle.close,
                        timestamp: Instant::now(),
                        volume: candle.volume,
                    };

                    // Buffer the data
                    self.buffer_market_data(market_data.clone());

                    // Analyze for signals
                    if let Some(signal) = self.analyze_market_data(&asset, &market_data) {
                        let _ = self.signal_sender.send(signal);
                    }
                }
                Ok(StreamEvent::Error(e)) => {
                    eprintln!("Stream error for {}: {}", asset, e);
                }
                Err(e) => {
                    eprintln!("Failed to receive event for {}: {}", asset, e);
                }
            }
        }
    }

    fn buffer_market_data(&mut self, data: MarketData) {
        let buffer = self.price_buffer.entry(data.asset.clone()).or_insert_with(Vec::new);
        buffer.push(data);

        // Keep only last 100 data points for performance
        if buffer.len() > 100 {
            buffer.drain(0..50); // Remove first 50 elements
        }
    }

    fn analyze_market_data(&self, asset: &str, current_data: &MarketData) -> Option<TradingSignal> {
        let buffer = self.price_buffer.get(asset)?;
        if buffer.len() < 20 { return None; } // Need minimum data

        // Calculate moving averages
        let short_ma = Self::calculate_moving_average(&buffer[buffer.len()-10..]);
        let long_ma = Self::calculate_moving_average(&buffer[buffer.len()-20..]);

        // Calculate momentum
        let momentum = (short_ma - long_ma) / long_ma * 100.0;

        // Generate signal if momentum is strong enough
        if momentum.abs() > 0.05 { // 0.05% threshold
            Some(TradingSignal {
                asset: asset.to_string(),
                action: if momentum > 0.0 { "call".to_string() } else { "put".to_string() },
                strength: momentum.abs(),
                price: current_data.price,
            })
        } else {
            None
        }
    }

    fn calculate_moving_average(data: &[MarketData]) -> f64 {
        data.iter().map(|d| d.price).sum::<f64>() / data.len() as f64
    }

    async fn setup_signal_processor(&self) -> mpsc::UnboundedReceiver<TradingSignal> {
        let (sender, receiver) = mpsc::unbounded_channel();
        self.signal_sender.clone(); // Store sender for later use
        receiver
    }

    async fn process_trading_signals(&self, receiver: &mut mpsc::UnboundedReceiver<TradingSignal>) {
        let mut active_orders = HashMap::new();
        let mut last_order_time = HashMap::new();

        while let Some(signal) = receiver.recv().await {
            // Rate limiting: only one order per asset every 2 minutes
            let now = Instant::now();
            if let Some(&last_time) = last_order_time.get(&signal.asset) {
                if now.duration_since(last_time) < Duration::from_secs(120) {
                    continue;
                }
            }

            // Check if we already have an active order for this asset
            if active_orders.contains_key(&signal.asset) {
                continue;
            }

            println!("üö® Signal: {} {} (strength: {:.3}%)", 
                signal.asset, signal.action.to_uppercase(), signal.strength);

            // Place order
            match self.place_order_from_signal(&signal).await {
                Ok(order_id) => {
                    active_orders.insert(signal.asset.clone(), order_id);
                    last_order_time.insert(signal.asset.clone(), now);
                }
                Err(e) => eprintln!("Failed to place order: {}", e),
            }
        }
    }

    async fn place_order_from_signal(&self, signal: &TradingSignal) -> Result<String, Box<dyn std::error::Error>> {
        let order_options = OrderOptions {
            asset: signal.asset.clone(),
            amount: 10.0, // Fixed amount for this example
            action: signal.action.clone(),
            expiration: 60,
        };

        let order_result = self.client.create_raw_order(order_options).await?;
        
        if order_result.success {
            println!("‚úÖ Order placed: {} {} $10 (ID: {})", 
                signal.asset, signal.action.to_uppercase(), order_result.order_id);
            
            // Schedule result check
            let client = self.client.clone();
            let order_id = order_result.order_id.clone();
            let asset = signal.asset.clone();
            
            tokio::spawn(async move {
                tokio::time::sleep(Duration::from_secs(65)).await;
                match client.check_win(&order_id).await {
                    Ok(result) => {
                        let emoji = match result.as_str() {
                            "win" => "‚úÖ",
                            "lose" => "‚ùå", 
                            _ => "‚è≥"
                        };
                        println!("{} {} order result: {}", emoji, asset, result);
                    }
                    Err(e) => eprintln!("Error checking order {}: {}", order_id, e),
                }
            });
            
            Ok(order_result.order_id)
        } else {
            Err(format!("Order failed: {}", order_result.message).into())
        }
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üöÄ Starting high-performance trading system...");

    let mut trader = HighPerformanceTrader::new("your_ssid_here").await?;
    
    let assets = vec!["EURUSD_otc", "GBPUSD_otc", "USDJPY_otc", "AUDUSD_otc"];
    
    trader.start_multi_asset_streaming(assets).await?;

    Ok(())
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="cta-section">
            <div class="container">
                <div class="cta-content fade-in-up">
                    <h2>Ready to Build Your Trading Bot?</h2>
                    <p>Professional bot development services available at chipa.tech</p>
                    <div class="cta-buttons">
                        <a href="https://chipa.tech" class="btn btn-primary" target="_blank">
                            Get Custom Bot
                        </a>
                        <a href="api.html" class="btn btn-outline">
                            API Reference
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>BinaryOptionsToolsV2</h3>
                    <p>Professional trading tools for binary options</p>
                    <div class="social-links">
                        <a href="#" aria-label="GitHub">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                            </svg>
                        </a>
                    </div>
                </div>
                <div class="footer-section">
                    <h4>Documentation</h4>
                    <ul>
                        <li><a href="python.html">Python</a></li>
                        <li><a href="javascript.html">JavaScript</a></li>
                        <li><a href="rust.html">Rust</a></li>
                        <li><a href="api.html">API Reference</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Examples</h4>
                    <ul>
                        <li><a href="#python">Python Examples</a></li>
                        <li><a href="#javascript">JavaScript Examples</a></li>
                        <li><a href="#rust">Rust Examples</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Services</h4>
                    <ul>
                        <li><a href="https://chipa.tech" target="_blank">Bot Development</a></li>
                        <li><a href="https://chipa.tech" target="_blank">Custom Solutions</a></li>
                        <li><a href="https://chipa.tech" target="_blank">Consulting</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 BinaryOptionsToolsV2. All rights reserved.</p>
                <p>Professional bot services by <a href="https://chipa.tech" target="_blank">chipa.tech</a></p>
            </div>
        </div>
    </footer>

    <script src="assets/js/main.js"></script>
    <script src="assets/js/animations.js"></script>
    <script src="assets/js/code-highlight.js"></script>
</body>
</html>
